var documenterSearchIndex = {"docs":
[{"location":"api/Optimisation/#API:-Turing.Optimisation","page":"Optimisation","title":"API: Turing.Optimisation","text":"","category":"section"},{"location":"api/Optimisation/","page":"Optimisation","title":"Optimisation","text":"Modules = [Turing.Optimisation]\nOrder  = [:type, :function]","category":"page"},{"location":"api/Optimisation/#SciMLBase.OptimizationProblem-Tuple{LogDensityFunction{V, M, C} where {M<:DynamicPPL.Model, C<:Turing.Optimisation.OptimizationContext, V<:DynamicPPL.VarInfo}, Any, Any}","page":"Optimisation","title":"SciMLBase.OptimizationProblem","text":"OptimizationProblem(log_density::OptimLogDensity, adtype, constraints)\n\nCreate an OptimizationProblem for the objective function defined by log_density.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.MAP","page":"Optimisation","title":"Turing.Optimisation.MAP","text":"MAP <: ModeEstimator\n\nConcrete type for maximum a posteriori estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.MLE","page":"Optimisation","title":"Turing.Optimisation.MLE","text":"MLE <: ModeEstimator\n\nConcrete type for maximum likelihood estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimationConstraints","page":"Optimisation","title":"Turing.Optimisation.ModeEstimationConstraints","text":"ModeEstimationConstraints\n\nA struct that holds constraints for mode estimation problems.\n\nThe fields are the same as possible constraints supported by the Optimization.jl: ub and lb specify lower and upper bounds of box constraints. cons is a function that takes the parameters of the model and returns a list of derived quantities, which are then constrained by the lower and upper bounds set by lcons and ucons. We refer to these as generic constraints. Please see the documentation of Optimization.jl for more details.\n\nAny of the fields can be nothing, disabling the corresponding constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimator","page":"Optimisation","title":"Turing.Optimisation.ModeEstimator","text":"ModeEstimator\n\nAn abstract type to mark whether mode estimation is to be done with maximum a posteriori (MAP) or maximum likelihood estimation (MLE). This is only needed for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult{\n    V<:NamedArrays.NamedArray,\n    M<:NamedArrays.NamedArray,\n    O<:Optim.MultivariateOptimizationResults,\n    S<:NamedArrays.NamedArray\n}\n\nA wrapper struct to store various results from a MAP or MLE estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult-Tuple{LogDensityFunction{V, M, C} where {M<:DynamicPPL.Model, C<:Turing.Optimisation.OptimizationContext, V<:DynamicPPL.VarInfo}, SciMLBase.OptimizationSolution}","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult(log_density::OptimLogDensity, solution::SciMLBase.OptimizationSolution)\n\nCreate a ModeResult for a given log_density objective and a solution given by solve.\n\nOptimization.solve returns its own result type. This function converts that into the richer format of ModeResult. It also takes care of transforming them back to the original parameter space in case the optimization was done in a transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity{M<:DynamicPPL.Model,C<:Context,V<:DynamicPPL.VarInfo}\n\nA struct that stores the negative log density function of a DynamicPPL model.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{AbstractVector}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"(f::OptimLogDensity)(z)\n(f::OptimLogDensity)(z, _)\n\nEvaluate the negative log joint or log likelihood at the array z. Which one is evaluated depends on the context of f.\n\nAny second argument is ignored. The two-argument method only exists to match interface the required by Optimization.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{DynamicPPL.Model, Turing.Optimisation.OptimizationContext}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity(model::DynamicPPL.Model, context::OptimizationContext)\n\nCreate a callable OptimLogDensity struct that evaluates a model using the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimizationContext","page":"Optimisation","title":"Turing.Optimisation.OptimizationContext","text":"OptimizationContext{C<:AbstractContext} <: AbstractContext\n\nThe OptimizationContext transforms variables to their constrained space, but does not use the density with respect to the transformation. This context is intended to allow an optimizer to sample in R^n freely.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Base.get-Tuple{Turing.Optimisation.ModeResult, AbstractVector{Symbol}}","page":"Optimisation","title":"Base.get","text":"Base.get(m::ModeResult, var_symbol::Symbol)\nBase.get(m::ModeResult, var_symbols::AbstractVector{Symbol})\n\nReturn the values of all the variables with the symbol(s) var_symbol in the mode result m. The return value is a NamedTuple with var_symbols as the key(s). The second argument should be either a Symbol or a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.estimate_mode","page":"Optimisation","title":"Turing.Optimisation.estimate_mode","text":"estimate_mode(\n    model::DynamicPPL.Model,\n    estimator::ModeEstimator,\n    [solver];\n    kwargs...\n)\n\nFind the mode of the probability distribution of a model.\n\nUnder the hood this function calls Optimization.solve.\n\nArguments\n\nmodel::DynamicPPL.Model: The model for which to estimate the mode.\nestimator::ModeEstimator: Can be either MLE() for maximum likelihood estimation or   MAP() for maximum a posteriori estimation.\nsolver=nothing. The optimization algorithm to use. Optional. Can be any solver   recognised by Optimization.jl. If omitted a default solver is used: LBFGS, or IPNewton   if non-box constraints are present.\n\nKeyword arguments\n\ninitial_params::Union{AbstractVector,Nothing}=nothing: Initial value for the   optimization. Optional, unless non-box constraints are specified. If omitted it is   generated by either sampling from the prior distribution or uniformly from the box   constraints, if any.\nadtype::AbstractADType=AutoForwardDiff(): The automatic differentiation type to use.\nKeyword arguments lb, ub, cons, lcons, and ucons define constraints for the   optimization problem. Please see ModeEstimationConstraints for more details.\nAny extra keyword arguments are passed to Optimization.solve.\n\n\n\n\n\n","category":"function"},{"location":"api/Optimisation/#Turing.Optimisation.generate_initial_params-Tuple{DynamicPPL.Model, Any, Any}","page":"Optimisation","title":"Turing.Optimisation.generate_initial_params","text":"generate_initial_params(model::DynamicPPL.Model, initial_params, constraints)\n\nGenerate an initial value for the optimization problem.\n\nIf initial_params is not nothing, a copy of it is returned. Otherwise initial parameter values are generated either by sampling from the prior (if no constraints are present) or uniformly from the box constraints. If generic constraints are set, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_a_posteriori-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_a_posteriori","text":"maximum_a_posteriori(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum a posteriori estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MAP() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_likelihood-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_likelihood","text":"maximum_likelihood(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum likelihood estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MLE() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#API:-Turing.Inference","page":"Inference","title":"API: Turing.Inference","text":"","category":"section"},{"location":"api/Inference/","page":"Inference","title":"Inference","text":"Modules = [Turing.Inference]\nOrder  = [:type, :function]","category":"page"},{"location":"api/Inference/#Turing.Inference.CSMC","page":"Inference","title":"Turing.Inference.CSMC","text":"CSMC(...)\n\nEquivalent to PG.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ESS","page":"Inference","title":"Turing.Inference.ESS","text":"ESS\n\nElliptical slice sampling algorithm.\n\nExamples\n\njulia> @model function gdemo(x)\n           m ~ Normal()\n           x ~ Normal(m, 0.5)\n       end\ngdemo (generic function with 2 methods)\n\njulia> sample(gdemo(1.0), ESS(), 1_000) |> mean\nMean\n\n│ Row │ parameters │ mean     │\n│     │ Symbol     │ Float64  │\n├─────┼────────────┼──────────┤\n│ 1   │ m          │ 0.824853 │\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Emcee","page":"Inference","title":"Turing.Inference.Emcee","text":"Emcee(n_walkers::Int, stretch_length=2.0)\n\nAffine-invariant ensemble sampling algorithm.\n\nReference\n\nForeman-Mackey, D., Hogg, D. W., Lang, D., & Goodman, J. (2013). emcee: The MCMC Hammer. Publications of the Astronomical Society of the Pacific, 125 (925), 306. https://doi.org/10.1086/670067\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ExternalSampler","page":"Inference","title":"Turing.Inference.ExternalSampler","text":"ExternalSampler{S<:AbstractSampler,AD<:ADTypes.AbstractADType,Unconstrained}\n\nRepresents a sampler that is not an implementation of InferenceAlgorithm.\n\nThe Unconstrained type-parameter is to indicate whether the sampler requires unconstrained space.\n\nFields\n\nsampler::AbstractMCMC.AbstractSampler: the sampler to wrap\nadtype::ADTypes.AbstractADType: the automatic differentiation (AD) backend to use\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Gibbs","page":"Inference","title":"Turing.Inference.Gibbs","text":"Gibbs(algs...)\n\nCompositional MCMC interface. Gibbs sampling combines one or more sampling algorithms, each of which samples from a different set of variables in a model.\n\nExample:\n\n@model function gibbs_example(x)\n    v1 ~ Normal(0,1)\n    v2 ~ Categorical(5)\nend\n\n# Use PG for a 'v2' variable, and use HMC for the 'v1' variable.\n# Note that v2 is discrete, so the PG sampler is more appropriate\n# than is HMC.\nalg = Gibbs(HMC(0.2, 3, :v1), PG(20, :v2))\n\nOne can also pass the number of iterations for each Gibbs component using the following syntax:\n\nalg = Gibbs((HMC(0.2, 3, :v1), n_hmc), (PG(20, :v2), n_pg))\n\nwhere n_hmc and n_pg are the number of HMC and PG iterations for each Gibbs iteration.\n\nTips:\n\nHMC and NUTS are fast samplers and can throw off particle-based\n\nmethods like Particle Gibbs. You can increase the effectiveness of particle sampling by including more particles in the particle sampler.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsConditional","page":"Inference","title":"Turing.Inference.GibbsConditional","text":"GibbsConditional(sym, conditional)\n\nA \"pseudo-sampler\" to manually provide analytical Gibbs conditionals to Gibbs. GibbsConditional(:x, cond) will sample the variable x according to the conditional cond, which must therefore be a function from a NamedTuple of the conditioned variables to a Distribution.\n\nThe NamedTuple that is passed in contains all random variables from the model in an unspecified order, taken from the VarInfo object over which the model is run. Scalars and vectors are stored in their respective shapes. The tuple also contains the value of the conditioned variable itself, which can be useful, but using it creates something that is not a Gibbs sampler anymore (see here).\n\nExamples\n\nα_0 = 2.0\nθ_0 = inv(3.0)\nx = [1.5, 2.0]\nN = length(x)\n\n@model function inverse_gdemo(x)\n    λ ~ Gamma(α_0, θ_0)\n    σ = sqrt(1 / λ)\n    m ~ Normal(0, σ)\n    @. x ~ $(Normal(m, σ))\nend\n\n# The conditionals can be formulated in terms of the following statistics:\nx_bar = mean(x) # sample mean\ns2 = var(x; mean=x_bar, corrected=false) # sample variance\nm_n = N * x_bar / (N + 1)\n\nfunction cond_m(c)\n    λ_n = c.λ * (N + 1)\n    σ_n = sqrt(1 / λ_n)\n    return Normal(m_n, σ_n)\nend\n\nfunction cond_λ(c)\n    α_n = α_0 + (N - 1) / 2 + 1\n    β_n = s2 * N / 2 + c.m^2 / 2 + inv(θ_0)\n    return Gamma(α_n, inv(β_n))\nend\n\nm = inverse_gdemo(x)\n\nsample(m, Gibbs(GibbsConditional(:λ, cond_λ), GibbsConditional(:m, cond_m)), 10)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsState","page":"Inference","title":"Turing.Inference.GibbsState","text":"GibbsState{V<:VarInfo, S<:Tuple{Vararg{Sampler}}}\n\nStores a VarInfo for use in sampling, and a Tuple of Samplers that the Gibbs sampler iterates through for each step!.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMC","page":"Inference","title":"Turing.Inference.HMC","text":"HMC(ϵ::Float64, n_leapfrog::Int; adtype::ADTypes.AbstractADType = AutoForwardDiff())\n\nHamiltonian Monte Carlo sampler with static trajectory.\n\nArguments\n\nϵ: The leapfrog step size to use.\nn_leapfrog: The number of leapfrog steps to use.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nUsage\n\nHMC(0.05, 10)\n\nTips\n\nIf you are receiving gradient errors when using HMC, try reducing the leapfrog step size ϵ, e.g.\n\n# Original step size\nsample(gdemo([1.5, 2]), HMC(0.1, 10), 1000)\n\n# Reduced step size\nsample(gdemo([1.5, 2]), HMC(0.01, 10), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMCDA","page":"Inference","title":"Turing.Inference.HMCDA","text":"HMCDA(\n    n_adapts::Int, δ::Float64, λ::Float64; ϵ::Float64 = 0.0;\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nHamiltonian Monte Carlo sampler with Dual Averaging algorithm.\n\nUsage\n\nHMCDA(200, 0.65, 0.3)\n\nArguments\n\nn_adapts: Numbers of samples to use for adaptation.\nδ: Target acceptance rate. 65% is often recommended.\nλ: Target leapfrog length.\nϵ: Initial step size; 0 means automatically search by Turing.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nReference\n\nFor more information, please view the following paper (arXiv link):\n\nHoffman, Matthew D., and Andrew Gelman. \"The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.\" Journal of Machine Learning Research 15, no. 1 (2014): 1593-1623.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.IS","page":"Inference","title":"Turing.Inference.IS","text":"IS()\n\nImportance sampling algorithm.\n\nUsage:\n\nIS()\n\nExample:\n\n# Define a simple Normal model with unknown mean and variance.\n@model function gdemo(x)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0,sqrt.(s))\n    x[1] ~ Normal(m, sqrt.(s))\n    x[2] ~ Normal(m, sqrt.(s))\n    return s², m\nend\n\nsample(gdemo([1.5, 2]), IS(), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.MH-Tuple","page":"Inference","title":"Turing.Inference.MH","text":"MH(space...)\n\nConstruct a Metropolis-Hastings algorithm.\n\nThe arguments space can be\n\nBlank (i.e. MH()), in which case MH defaults to using the prior for each parameter as the proposal distribution.\nA set of one or more symbols to sample with MH in conjunction with Gibbs, i.e. Gibbs(MH(:m), PG(10, :s))\nAn iterable of pairs or tuples mapping a Symbol to a AdvancedMH.Proposal, Distribution, or Function that generates returns a conditional proposal distribution.\nA covariance matrix to use as for mean-zero multivariate normal proposals.\n\nExamples\n\nThe default MH will use propose samples from the prior distribution using AdvancedMH.StaticProposal.\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\nchain = sample(gdemo(1.5, 2.0), MH(), 1_000)\nmean(chain)\n\nAlternatively, you can specify particular parameters to sample if you want to combine sampling from multiple samplers:\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\n# Samples s with MH and m with PG\nchain = sample(gdemo(1.5, 2.0), Gibbs(MH(:s), PG(10, :m)), 1_000)\nmean(chain)\n\nUsing custom distributions defaults to using static MH:\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\n# Use a static proposal for s and random walk with proposal\n# standard deviation of 0.25 for m.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s => InverseGamma(2, 3),\n        :m => Normal(0, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nSpecifying explicit proposals using the AdvancedMH interface:\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\n# Use a static proposal for s and random walk with proposal\n# standard deviation of 0.25 for m.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s => AdvancedMH.StaticProposal(InverseGamma(2,3)),\n        :m => AdvancedMH.RandomWalkProposal(Normal(0, 0.25))\n    ),\n    1_000\n)\nmean(chain)\n\nUsing a custom function to specify a conditional distribution:\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\n# Use a static proposal for s and and a conditional proposal for m,\n# where the proposal is centered around the current sample.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s => InverseGamma(2, 3),\n        :m => x -> Normal(x, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nProviding a covariance matrix will cause MH to perform random-walk sampling in the transformed space with proposals drawn from a multivariate normal distribution. The provided matrix must be positive semi-definite and square. Usage:\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\n# Providing a custom variance-covariance matrix\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        [0.25 0.05;\n         0.05 0.50]\n    ),\n    1_000\n)\nmean(chain)\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.MHLogDensityFunction","page":"Inference","title":"Turing.Inference.MHLogDensityFunction","text":"MHLogDensityFunction\n\nA log density function for the MH sampler.\n\nThis variant uses the  set_namedtuple! function to update the VarInfo.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.NUTS","page":"Inference","title":"Turing.Inference.NUTS","text":"NUTS(n_adapts::Int, δ::Float64; max_depth::Int=10, Δ_max::Float64=1000.0, init_ϵ::Float64=0.0; adtype::ADTypes.AbstractADType=AutoForwardDiff()\n\nNo-U-Turn Sampler (NUTS) sampler.\n\nUsage:\n\nNUTS()            # Use default NUTS configuration.\nNUTS(1000, 0.65)  # Use 1000 adaption steps, and target accept ratio 0.65.\n\nArguments:\n\nn_adapts::Int : The number of samples to use with adaptation.\nδ::Float64 : Target acceptance rate for dual averaging.\nmax_depth::Int : Maximum doubling tree depth.\nΔ_max::Float64 : Maximum divergence during doubling tree.\ninit_ϵ::Float64 : Initial step size; 0 means automatically searching using a heuristic procedure.\nadtype::ADTypes.AbstractADType : The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG","page":"Inference","title":"Turing.Inference.PG","text":"PG(n, space...)\nPG(n, [resampler = AdvancedPS.ResampleWithESSThreshold(), space = ()])\nPG(n, [resampler = AdvancedPS.resample_systematic, ]threshold[, space = ()])\n\nCreate a Particle Gibbs sampler of type PG with n particles for the variables in space.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG-2","page":"Inference","title":"Turing.Inference.PG","text":"struct PG{space, R} <: Turing.Inference.ParticleInference\n\nParticle Gibbs sampler.\n\nFields\n\nnparticles::Int64: Number of particles.\nresampler::Any: Resampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PolynomialStepsize-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Inference","title":"Turing.Inference.PolynomialStepsize","text":"PolynomialStepsize(a[, b=0, γ=0.55])\n\nCreate a polynomially decaying stepsize function.\n\nAt iteration t, the step size is\n\na (b + t)^-γ\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.Prior","page":"Inference","title":"Turing.Inference.Prior","text":"Prior()\n\nAlgorithm for sampling from the prior.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC{AD,space}\n\nStochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.e\n\nFields\n\nlearning_rate::Real\nmomentum_decay::Real\nadtype::Any\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC-Tuple{Vararg{Symbol}}","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC(\n    space::Symbol...;\n    learning_rate::Real,\n    momentum_decay::Real,\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nCreate a Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SGLD","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nFields\n\nstepsize::Any: Step size function.\nadtype::Any\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGLD-Tuple{Vararg{Symbol}}","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD(\n    space::Symbol...;\n    stepsize = PolynomialStepsize(0.01),\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nBy default, a polynomially decaying stepsize is used.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\nSee also: PolynomialStepsize\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SMC","page":"Inference","title":"Turing.Inference.SMC","text":"SMC(space...)\nSMC([resampler = AdvancedPS.ResampleWithESSThreshold(), space = ()])\nSMC([resampler = AdvancedPS.resample_systematic, ]threshold[, space = ()])\n\nCreate a sequential Monte Carlo sampler of type SMC for the variables in space.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SMC-2","page":"Inference","title":"Turing.Inference.SMC","text":"struct SMC{space, R} <: Turing.Inference.ParticleInference\n\nSequential Monte Carlo sampler.\n\nFields\n\nresampler::Any\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#StatsAPI.predict-Tuple{DynamicPPL.Model, Chains}","page":"Inference","title":"StatsAPI.predict","text":"predict([rng::AbstractRNG,] model::Model, chain::MCMCChains.Chains; include_all=false)\n\nExecute model conditioned on each sample in chain, and return the resulting Chains.\n\nIf include_all is false, the returned Chains will contain only those variables sampled/not present in chain.\n\nDetails\n\nInternally calls Turing.Inference.transitions_from_chain to obtained the samples and then converts these into a Chains object using AbstractMCMC.bundle_samples.\n\nExample\n\njulia> using Turing; Turing.setprogress!(false);\n[ Info: [Turing]: progress logging is disabled globally\n\njulia> @model function linear_reg(x, y, σ = 0.1)\n           β ~ Normal(0, 1)\n\n           for i ∈ eachindex(y)\n               y[i] ~ Normal(β * x[i], σ)\n           end\n       end;\n\njulia> σ = 0.1; f(x) = 2 * x + 0.1 * randn();\n\njulia> Δ = 0.1; xs_train = 0:Δ:10; ys_train = f.(xs_train);\n\njulia> xs_test = [10 + Δ, 10 + 2 * Δ]; ys_test = f.(xs_test);\n\njulia> m_train = linear_reg(xs_train, ys_train, σ);\n\njulia> chain_lin_reg = sample(m_train, NUTS(100, 0.65), 200);\n┌ Info: Found initial step size\n└   ϵ = 0.003125\n\njulia> m_test = linear_reg(xs_test, Vector{Union{Missing, Float64}}(undef, length(ys_test)), σ);\n\njulia> predictions = predict(m_test, chain_lin_reg)\nObject of type Chains, with data of type 100×2×1 Array{Float64,3}\n\nIterations        = 1:100\nThinning interval = 1\nChains            = 1\nSamples per chain = 100\nparameters        = y[1], y[2]\n\n2-element Array{ChainDataFrame,1}\n\nSummary Statistics\n  parameters     mean     std  naive_se     mcse       ess   r_hat\n  ──────────  ───────  ──────  ────────  ───────  ────────  ──────\n        y[1]  20.1974  0.1007    0.0101  missing  101.0711  0.9922\n        y[2]  20.3867  0.1062    0.0106  missing  101.4889  0.9903\n\nQuantiles\n  parameters     2.5%    25.0%    50.0%    75.0%    97.5%\n  ──────────  ───────  ───────  ───────  ───────  ───────\n        y[1]  20.0342  20.1188  20.2135  20.2588  20.4188\n        y[2]  20.1870  20.3178  20.3839  20.4466  20.5895\n\n\njulia> ys_pred = vec(mean(Array(group(predictions, :y)); dims = 1));\n\njulia> sum(abs2, ys_test - ys_pred) ≤ 0.1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.dist_val_tuple-Tuple{DynamicPPL.Sampler{<:MH}, Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta}","page":"Inference","title":"Turing.Inference.dist_val_tuple","text":"dist_val_tuple(spl::Sampler{<:MH}, vi::VarInfo)\n\nReturn two NamedTuples.\n\nThe first NamedTuple has symbols as keys and distributions as values. The second NamedTuple has model symbols as keys and their stored values as values.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.externalsampler-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.externalsampler","text":"externalsampler(sampler::AbstractSampler; adtype=AutoForwardDiff(), unconstrained=true)\n\nWrap a sampler so it can be used as an inference algorithm.\n\nArguments\n\nsampler::AbstractSampler: The sampler to wrap.\n\nKeyword Arguments\n\nadtype::ADTypes.AbstractADType=ADTypes.AutoForwardDiff(): The automatic differentiation (AD) backend to use.\nunconstrained::Bool=true: Whether the sampler requires unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.getparams-Tuple{Any, Any}","page":"Inference","title":"Turing.Inference.getparams","text":"getparams(model, t)\n\nReturn a named tuple of parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_rerun-Tuple{Any, Any}","page":"Inference","title":"Turing.Inference.gibbs_rerun","text":"gibbs_rerun(prev_alg, alg)\n\nCheck if the model should be rerun to recompute the log density before sampling with the Gibbs component alg and after sampling from Gibbs component prev_alg.\n\nBy default, the function returns true.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_state-Tuple{Any, Any, DynamicPPL.AbstractVarInfo, DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.gibbs_state","text":"gibbs_state(model, sampler, state, varinfo)\n\nReturn an updated state, taking into account the variables sampled by other Gibbs components.\n\nArguments\n\nmodel: model targeted by the Gibbs sampler.\nsampler: the sampler for this Gibbs component.\nstate: the state of sampler computed in the previous iteration.\nvarinfo: the variables, including the ones sampled by other Gibbs components.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_varinfo-Tuple{Any, Any, Any}","page":"Inference","title":"Turing.Inference.gibbs_varinfo","text":"gibbs_varinfo(model, sampler, state)\n\nReturn the variables corresponding to the current state of the Gibbs component sampler.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.group_varnames_by_symbol-Tuple{Any}","page":"Inference","title":"Turing.Inference.group_varnames_by_symbol","text":"group_varnames_by_symbol(vns)\n\nGroup the varnames by their symbol.\n\nArguments\n\nvns: Iterable of VarName.\n\nReturns\n\nOrderedDict{Symbol, Vector{VarName}}: A dictionary mapping symbol to a vector of varnames.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.isgibbscomponent-Tuple{Any}","page":"Inference","title":"Turing.Inference.isgibbscomponent","text":"isgibbscomponent(alg)\n\nDetermine whether algorithm alg is allowed as a Gibbs component.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.mh_accept-Tuple{Real, Real, Real}","page":"Inference","title":"Turing.Inference.mh_accept","text":"mh_accept(logp_current::Real, logp_proposal::Real, log_proposal_ratio::Real)\n\nDecide if a proposal x with log probability log p(x) = logp_proposal and log proposal ratio log k(x x) - log k(x x) = log_proposal_ratio in a Metropolis-Hastings algorithm with Markov kernel k(x_t x_t+1) and current state x with log probability log p(x) = logp_current is accepted by evaluating the Metropolis-Hastings acceptance criterion\n\nlog U leq log p(x) - log p(x) + log k(x x) - log k(x x)\n\nfor a uniform random number U in 0 1).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.recompute_logprob!!-Tuple{Random.AbstractRNG, DynamicPPL.Model, DynamicPPL.Sampler{<:Turing.Inference.ExternalSampler}, Any}","page":"Inference","title":"Turing.Inference.recompute_logprob!!","text":"recompute_logprob!!(rng, model, sampler, state)\n\nRecompute the log-probability of the model based on the given state and return the resulting state.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.requires_unconstrained_space-Union{Tuple{Turing.Inference.ExternalSampler{<:Any, <:Any, Unconstrained}}, Tuple{Unconstrained}} where Unconstrained","page":"Inference","title":"Turing.Inference.requires_unconstrained_space","text":"requires_unconstrained_space(sampler::ExternalSampler)\n\nReturn true if the sampler requires unconstrained space, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_namedtuple!-Tuple{Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta, NamedTuple}","page":"Inference","title":"Turing.Inference.set_namedtuple!","text":"set_namedtuple!(vi::VarInfo, nt::NamedTuple)\n\nPlaces the values of a NamedTuple into the relevant places of a VarInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.transitions_from_chain-Tuple{DynamicPPL.Model, Chains}","page":"Inference","title":"Turing.Inference.transitions_from_chain","text":"transitions_from_chain(\n    [rng::AbstractRNG,]\n    model::Model,\n    chain::MCMCChains.Chains;\n    sampler = DynamicPPL.SampleFromPrior()\n)\n\nExecute model conditioned on each sample in chain, and return resulting transitions.\n\nThe returned transitions are represented in a Vector{<:Turing.Inference.Transition}.\n\nDetails\n\nIn a bit more detail, the process is as follows:\n\nFor every sample in chain\nFor every variable in sample\nSet variable in model to its value in sample\nExecute model with variables fixed as above, sampling variables NOT present in chain using SampleFromPrior\nReturn sampled variables and log-joint\n\nExample\n\njulia> using Turing\n\njulia> @model function demo()\n           m ~ Normal(0, 1)\n           x ~ Normal(m, 1)\n       end;\n\njulia> m = demo();\n\njulia> chain = Chains(randn(2, 1, 1), [\"m\"]); # 2 samples of `m`\n\njulia> transitions = Turing.Inference.transitions_from_chain(m, chain);\n\njulia> [Turing.Inference.getlogp(t) for t in transitions] # extract the logjoints\n2-element Array{Float64,1}:\n -3.6294991938628374\n -2.5697948166987845\n\njulia> [first(t.θ.x) for t in transitions] # extract samples for `x`\n2-element Array{Array{Float64,1},1}:\n [-2.0844148956440796]\n [-1.704630494695469]\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Module-wide-re-exports","page":"API","title":"Module-wide re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Turing.jl directly re-exports the entire public API of the following packages:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Distributions.jl\nMCMCChains.jl\nAbstractMCMC.jl\nBijectors.jl\nLibtask.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Please see the individual packages for their documentation.","category":"page"},{"location":"api/#Individual-exports-and-re-exports","page":"API","title":"Individual exports and re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"All of the following symbols are exported unqualified by Turing, even though the documentation suggests that many of them are qualified. That means, for example, you can just write","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Turing\n\n@model function my_model(...)\n\nsample(my_model(), Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"instead of","category":"page"},{"location":"api/","page":"API","title":"API","text":"sample(model, Turing.Inference.Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"even though Prior() is actually defined in the Turing.Inference module.","category":"page"},{"location":"api/#Modelling","page":"API","title":"Modelling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\n@model DynamicPPL.@model Define a probabilistic model\n@varname AbstractPPL.@varname Generate a VarName from a Julia expression\n@submodel DynamicPPL.@submodel Define a submodel","category":"page"},{"location":"api/#Inference","page":"API","title":"Inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nsample StatsBase.sample Sample from a model","category":"page"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nPrior Turing.Inference.Prior Sample from the prior distribution\nMH Turing.Inference.MH Metropolis–Hastings\nEmcee Turing.Inference.Emcee Affine-invariant ensemble sampler\nESS Turing.Inference.ESS Elliptical slice sampling\nGibbs Turing.Inference.Gibbs Gibbs sampling\nGibbsConditional Turing.Inference.GibbsConditional A \"pseudo-sampler\" to provide analytical conditionals to Gibbs\nHMC Turing.Inference.HMC Hamiltonian Monte Carlo\nSGLD Turing.Inference.SGLD Stochastic gradient Langevin dynamics\nSGHMC Turing.Inference.SGHMC Stochastic gradient Hamiltonian Monte Carlo\nPolynomialStepsize Turing.Inference.PolynomialStepsize Returns a function which generates polynomially decaying step sizes\nHMCDA Turing.Inference.HMCDA Hamiltonian Monte Carlo with dual averaging\nNUTS Turing.Inference.NUTS No-U-Turn Sampler\nIS Turing.Inference.IS Importance sampling\nSMC Turing.Inference.SMC Sequential Monte Carlo\nPG Turing.Inference.PG Particle Gibbs\nCSMC Turing.Inference.CSMC The same as PG\nexternalsampler Turing.Inference.externalsampler Wrap an external sampler for use in Turing","category":"page"},{"location":"api/#Variational-inference","page":"API","title":"Variational inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These functions are not (yet) formally documented. Please see the variational inference tutorial for a walkthrough on how to use these.","category":"page"},{"location":"api/","page":"API","title":"API","text":"TODO: Generate docs for AdvancedVI 0.2, update the InterLinks object.inv, and update the table below to include @extref.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nvi AdvancedVI.vi Perform variational inference\nADVI AdvancedVI.ADVI Construct an instance of a VI algorithm","category":"page"},{"location":"api/#Automatic-differentiation-types","page":"API","title":"Automatic differentiation types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These are used to specify the automatic differentiation backend to use.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nAutoForwardDiff ADTypes.AutoForwardDiff ForwardDiff.jl backend\nAutoReverseDiff ADTypes.AutoReverseDiff ReverseDiff.jl backend\nAutoZygote ADTypes.AutoZygote Zygote.jl backend\nAutoTracker ADTypes.AutoTracker Tracker.jl backend\nAutoTapir ADTypes.AutoTapir Tapir.jl backend, only for ADTypes >= 1.0","category":"page"},{"location":"api/#Debugging","page":"API","title":"Debugging","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"setprogress!","category":"page"},{"location":"api/#Turing.setprogress!","page":"API","title":"Turing.setprogress!","text":"setprogress!(progress::Bool)\n\nEnable progress logging in Turing if progress is true, and disable it otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Distributions","page":"API","title":"Distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These distributions are defined in Turing.jl, but not in Distributions.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Flat\nFlatPos\nBinomialLogit\nOrderedLogistic\nLogPoisson","category":"page"},{"location":"api/#Turing.Flat","page":"API","title":"Turing.Flat","text":"Flat()\n\nThe flat distribution is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = 1\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.FlatPos","page":"API","title":"Turing.FlatPos","text":"FlatPos(l::Real)\n\nThe positive flat distribution with real-valued parameter l is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = begincases\n0  textif  x leq l \n1  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.BinomialLogit","page":"API","title":"Turing.BinomialLogit","text":"BinomialLogit(n, logitp)\n\nThe Binomial distribution with logit parameterization characterizes the number of successes in a sequence of independent trials.\n\nIt has two parameters: n, the number of trials, and logitp, the logit of the probability of success in an individual trial, with the distribution\n\nP(X = k) = n choose k(textlogistic(logitp))^k (1 - textlogistic(logitp))^n-k quad text for  k = 012 ldots n\n\nSee also: Binomial\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.OrderedLogistic","page":"API","title":"Turing.OrderedLogistic","text":"OrderedLogistic(η, c::AbstractVector)\n\nThe ordered logistic distribution with real-valued parameter η and cutpoints c has the probability mass function\n\nP(X = k) = begincases\n    1 - textlogistic(eta - c_1)  textif  k = 1 \n    textlogistic(eta - c_k-1) - textlogistic(eta - c_k)  textif  1  k  K \n    textlogistic(eta - c_K-1)  textif  k = K\nendcases\n\nwhere K = length(c) + 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.LogPoisson","page":"API","title":"Turing.LogPoisson","text":"LogPoisson(logλ)\n\nThe Poisson distribution with logarithmic parameterization of the rate parameter describes the number of independent events occurring within a unit time interval, given the average rate of occurrence exp(loglambda).\n\nThe distribution has the probability mass function\n\nP(X = k) = frace^k cdot loglambdak e^-e^loglambda quad text for  k = 012ldots\n\nSee also: Poisson\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"BernoulliLogit is part of Distributions.jl since version 0.25.77. If you are using an older version of Distributions where this isn't defined, Turing will export the same distribution.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Distributions.BernoulliLogit","category":"page"},{"location":"api/#Distributions.BernoulliLogit","page":"API","title":"Distributions.BernoulliLogit","text":"BernoulliLogit(logitp=0.0)\n\nA Bernoulli distribution that is parameterized by the logit logitp = logit(p) = log(p/(1-p)) of its success rate p.\n\nP(X = k) = begincases\noperatornamelogistic(-logitp) = frac11 + exp(logitp)  quad textfor  k = 0 \noperatornamelogistic(logitp) = frac11 + exp(-logitp)  quad textfor  k = 1\nendcases\n\nExternal links:\n\nBernoulli distribution on Wikipedia\n\nSee also Bernoulli\n\n\n\n\n\n","category":"type"},{"location":"api/#Tools-to-work-with-distributions","page":"API","title":"Tools to work with distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TODO: DistributionsAD needs docs","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nfilldist DistributionsAD.filldist Create a product distribution from a distribution and integers\narraydist DistributionsAD.arraydist Create a product distribution from an array of distributions\nNamedDist DynamicPPL.NamedDist A distribution that carries the name of the variable","category":"page"},{"location":"api/#Predictions","page":"API","title":"Predictions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"predict","category":"page"},{"location":"api/#StatsAPI.predict","page":"API","title":"StatsAPI.predict","text":"predict([rng::AbstractRNG,] model::Model, chain::MCMCChains.Chains; include_all=false)\n\nExecute model conditioned on each sample in chain, and return the resulting Chains.\n\nIf include_all is false, the returned Chains will contain only those variables sampled/not present in chain.\n\nDetails\n\nInternally calls Turing.Inference.transitions_from_chain to obtained the samples and then converts these into a Chains object using AbstractMCMC.bundle_samples.\n\nExample\n\njulia> using Turing; Turing.setprogress!(false);\n[ Info: [Turing]: progress logging is disabled globally\n\njulia> @model function linear_reg(x, y, σ = 0.1)\n           β ~ Normal(0, 1)\n\n           for i ∈ eachindex(y)\n               y[i] ~ Normal(β * x[i], σ)\n           end\n       end;\n\njulia> σ = 0.1; f(x) = 2 * x + 0.1 * randn();\n\njulia> Δ = 0.1; xs_train = 0:Δ:10; ys_train = f.(xs_train);\n\njulia> xs_test = [10 + Δ, 10 + 2 * Δ]; ys_test = f.(xs_test);\n\njulia> m_train = linear_reg(xs_train, ys_train, σ);\n\njulia> chain_lin_reg = sample(m_train, NUTS(100, 0.65), 200);\n┌ Info: Found initial step size\n└   ϵ = 0.003125\n\njulia> m_test = linear_reg(xs_test, Vector{Union{Missing, Float64}}(undef, length(ys_test)), σ);\n\njulia> predictions = predict(m_test, chain_lin_reg)\nObject of type Chains, with data of type 100×2×1 Array{Float64,3}\n\nIterations        = 1:100\nThinning interval = 1\nChains            = 1\nSamples per chain = 100\nparameters        = y[1], y[2]\n\n2-element Array{ChainDataFrame,1}\n\nSummary Statistics\n  parameters     mean     std  naive_se     mcse       ess   r_hat\n  ──────────  ───────  ──────  ────────  ───────  ────────  ──────\n        y[1]  20.1974  0.1007    0.0101  missing  101.0711  0.9922\n        y[2]  20.3867  0.1062    0.0106  missing  101.4889  0.9903\n\nQuantiles\n  parameters     2.5%    25.0%    50.0%    75.0%    97.5%\n  ──────────  ───────  ───────  ───────  ───────  ───────\n        y[1]  20.0342  20.1188  20.2135  20.2588  20.4188\n        y[2]  20.1870  20.3178  20.3839  20.4466  20.5895\n\n\njulia> ys_pred = vec(mean(Array(group(predictions, :y)); dims = 1));\n\njulia> sum(abs2, ys_test - ys_pred) ≤ 0.1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Re-exports-from-DynamicPPL-/-AbstractPPL","page":"API","title":"Re-exports from DynamicPPL / AbstractPPL","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\npointwise_loglikelihoods DynamicPPL.pointwise_loglikelihoods Compute log likelihoods for each sample in a chain\ngenerated_quantities DynamicPPL.generated_quantities Calculate additional quantities defined in a model\nlogprior DynamicPPL.logprior Compute log prior probability\nlogjoint DynamicPPL.logjoint Compute log joint probability\nLogDensityFunction DynamicPPL.LogDensityFunction Wrap a Turing model to satisfy LogDensityFunctions.jl interface\ncondition AbstractPPL.condition Condition a model on data\ndecondition AbstractPPL.decondition Remove conditioning on data\nconditioned DynamicPPL.conditioned Return the conditioned values of a model\nfix DynamicPPL.fix Fix the value of a variable\nunfix DynamicPPL.unfix Unfix the value of a variable\nOrderedDict OrderedCollections.OrderedDict An ordered dictionary","category":"page"},{"location":"api/#Extra-re-exports-from-Bijectors","page":"API","title":"Extra re-exports from Bijectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Note that Bijectors itself does not export ordered.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Bijectors.ordered","category":"page"},{"location":"api/#Bijectors.ordered","page":"API","title":"Bijectors.ordered","text":"ordered(d::Distribution)\n\nReturn a Distribution whose support are ordered vectors, i.e., vectors with increasingly ordered elements.\n\nSpecifically, d is restricted to the subspace of its domain containing only ordered elements.\n\nwarning: Warning\nrand is implemented using rejection sampling, which can be slow for high-dimensional distributions. In such cases, consider using MCMC methods to sample from the distribution instead.\n\nwarning: Warning\nThe resulting ordered distribution is un-normalized, which can cause issues in some contexts, e.g. in hierarchical models where the parameters of the ordered distribution are themselves sampled. See the notes below for a more detailed discussion.\n\nNotes on ordered being un-normalized\n\nThe resulting ordered distribution is un-normalized. This is not a problem if used in a context where the normalizing factor is irrelevant, but if the value of the normalizing factor impacts the resulting computation, the results may be inaccurate.\n\nFor example, if the distribution is used in sampling a posterior distribution with MCMC and the parameters of the ordered distribution are themselves sampled, then the normalizing factor would in general be needed for accurate sampling, and ordered should not be used. However, if the parameters are fixed, then since MCMC does not require distributions be normalized, ordered may be used without problems.\n\nA common case is where the distribution being ordered is a joint distribution of n identical univariate distributions. In this case the normalization factor works out to be the constant n!, and ordered can again be used without problems even if the parameters of the univariate distribution are sampled.\n\n\n\n\n\n","category":"function"},{"location":"api/#Point-estimates","page":"API","title":"Point estimates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nmaximum_a_posteriori Turing.Optimisation.maximum_a_posteriori Find a MAP estimate for a model\nmaximum_likelihood Turing.Optimisation.maximum_likelihood Find a MLE estimate for a model\nMAP Turing.Optimisation.MAP Type to use with Optim.jl for MAP estimation\nMLE Turing.Optimisation.MLE Type to use with Optim.jl for MLE estimation","category":"page"},{"location":"#Turing.jl","page":"Home","title":"Turing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This site contains the API documentation for the identifiers exported by Turing.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are looking for usage examples and guides, please visit https://turinglang.org/docs.","category":"page"}]
}
