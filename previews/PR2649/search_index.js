var documenterSearchIndex = {"docs":
[{"location":"api/Optimisation/#API:-Turing.Optimisation","page":"Optimisation","title":"API: Turing.Optimisation","text":"","category":"section"},{"location":"api/Optimisation/#SciMLBase.OptimizationProblem-Tuple{Turing.Optimisation.OptimLogDensity, Any, Any}","page":"Optimisation","title":"SciMLBase.OptimizationProblem","text":"OptimizationProblem(log_density::OptimLogDensity, adtype, constraints)\n\nCreate an OptimizationProblem for the objective function defined by log_density.\n\nNote that the adtype parameter here overrides any adtype parameter the OptimLogDensity was constructed with.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.MAP","page":"Optimisation","title":"Turing.Optimisation.MAP","text":"MAP <: ModeEstimator\n\nConcrete type for maximum a posteriori estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.MLE","page":"Optimisation","title":"Turing.Optimisation.MLE","text":"MLE <: ModeEstimator\n\nConcrete type for maximum likelihood estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimationConstraints","page":"Optimisation","title":"Turing.Optimisation.ModeEstimationConstraints","text":"ModeEstimationConstraints\n\nA struct that holds constraints for mode estimation problems.\n\nThe fields are the same as possible constraints supported by the Optimization.jl: ub and lb specify lower and upper bounds of box constraints. cons is a function that takes the parameters of the model and returns a list of derived quantities, which are then constrained by the lower and upper bounds set by lcons and ucons. We refer to these as generic constraints. Please see the documentation of Optimization.jl for more details.\n\nAny of the fields can be nothing, disabling the corresponding constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimator","page":"Optimisation","title":"Turing.Optimisation.ModeEstimator","text":"ModeEstimator\n\nAn abstract type to mark whether mode estimation is to be done with maximum a posteriori (MAP) or maximum likelihood estimation (MLE). This is only needed for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult{\n    V<:NamedArrays.NamedArray,\n    M<:NamedArrays.NamedArray,\n    O<:Optim.MultivariateOptimizationResults,\n    S<:NamedArrays.NamedArray\n}\n\nA wrapper struct to store various results from a MAP or MLE estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult-Tuple{Turing.Optimisation.OptimLogDensity, SciMLBase.OptimizationSolution}","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult(log_density::OptimLogDensity, solution::SciMLBase.OptimizationSolution)\n\nCreate a ModeResult for a given log_density objective and a solution given by solve.\n\nOptimization.solve returns its own result type. This function converts that into the richer format of ModeResult. It also takes care of transforming them back to the original parameter space in case the optimization was done in a transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity{\n    M<:DynamicPPL.Model,\n    F<:Function,\n    V<:DynamicPPL.AbstractVarInfo,\n    AD<:ADTypes.AbstractADType,\n}\n\nA struct that wraps a single LogDensityFunction. Can be invoked either using\n\nOptimLogDensity(model, varinfo; adtype=adtype)\n\nor\n\nOptimLogDensity(model; adtype=adtype)\n\nIf not specified, adtype defaults to AutoForwardDiff().\n\nAn OptimLogDensity does not, in itself, obey the LogDensityProblems interface. Thus, if you want to calculate the log density of its contents at the point z, you should manually call\n\nLogDensityProblems.logdensity(f.ldf, z)\n\nHowever, it is a callable object which returns the negative log density of the underlying LogDensityFunction at the point z. This is done to satisfy the Optim.jl interface.\n\noptim_ld = OptimLogDensity(model, varinfo)\noptim_ld(z)  # returns -logp\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{AbstractVector}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"(f::OptimLogDensity)(z)\n(f::OptimLogDensity)(z, _)\n\nEvaluate the negative log joint or log likelihood at the array z. Which one is evaluated depends on the context of f.\n\nAny second argument is ignored. The two-argument method only exists to match interface the required by Optimization.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Base.get-Tuple{Turing.Optimisation.ModeResult, AbstractVector{Symbol}}","page":"Optimisation","title":"Base.get","text":"Base.get(m::ModeResult, var_symbol::Symbol)\nBase.get(m::ModeResult, var_symbols::AbstractVector{Symbol})\n\nReturn the values of all the variables with the symbol(s) var_symbol in the mode result m. The return value is a NamedTuple with var_symbols as the key(s). The second argument should be either a Symbol or a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#StatsAPI.coeftable-Tuple{Turing.Optimisation.ModeResult}","page":"Optimisation","title":"StatsAPI.coeftable","text":"StatsBase.coeftable(m::ModeResult; level::Real=0.95, numerrors_warnonly::Bool=true)\n\nReturn a table with coefficients and related statistics of the model. level determines the level for confidence intervals (by default, 95%).\n\nIn case the numerrors_warnonly argument is true (the default) numerical errors encountered during the computation of the standard errors will be caught and reported in an extra \"Error notes\" column.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.estimate_mode","page":"Optimisation","title":"Turing.Optimisation.estimate_mode","text":"estimate_mode(\n    model::DynamicPPL.Model,\n    estimator::ModeEstimator,\n    [solver];\n    kwargs...\n)\n\nFind the mode of the probability distribution of a model.\n\nUnder the hood this function calls Optimization.solve.\n\nArguments\n\nmodel::DynamicPPL.Model: The model for which to estimate the mode.\nestimator::ModeEstimator: Can be either MLE() for maximum likelihood estimation or   MAP() for maximum a posteriori estimation.\nsolver=nothing. The optimization algorithm to use. Optional. Can be any solver   recognised by Optimization.jl. If omitted a default solver is used: LBFGS, or IPNewton   if non-box constraints are present.\n\nKeyword arguments\n\ncheck_model::Bool=true: If true, the model is checked for errors before   optimisation begins.\ninitial_params::Union{AbstractVector,Nothing}=nothing: Initial value for the   optimization. Optional, unless non-box constraints are specified. If omitted it is   generated by either sampling from the prior distribution or uniformly from the box   constraints, if any.\nadtype::AbstractADType=AutoForwardDiff(): The automatic differentiation type to use.\nKeyword arguments lb, ub, cons, lcons, and ucons define constraints for the   optimization problem. Please see ModeEstimationConstraints for more details.\nAny extra keyword arguments are passed to Optimization.solve.\n\n\n\n\n\n","category":"function"},{"location":"api/Optimisation/#Turing.Optimisation.generate_initial_params-Tuple{DynamicPPL.Model, Any, Any}","page":"Optimisation","title":"Turing.Optimisation.generate_initial_params","text":"generate_initial_params(model::DynamicPPL.Model, initial_params, constraints)\n\nGenerate an initial value for the optimization problem.\n\nIf initial_params is not nothing, a copy of it is returned. Otherwise initial parameter values are generated either by sampling from the prior (if no constraints are present) or uniformly from the box constraints. If generic constraints are set, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_a_posteriori-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_a_posteriori","text":"maximum_a_posteriori(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum a posteriori estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MAP() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_likelihood-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_likelihood","text":"maximum_likelihood(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum likelihood estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MLE() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#API:-Turing.Inference","page":"Inference","title":"API: Turing.Inference","text":"","category":"section"},{"location":"api/Inference/#Turing.Inference.CSMC","page":"Inference","title":"Turing.Inference.CSMC","text":"CSMC(...)\n\nEquivalent to PG.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ESS","page":"Inference","title":"Turing.Inference.ESS","text":"ESS\n\nElliptical slice sampling algorithm.\n\nExamples\n\njulia> @model function gdemo(x)\n           m ~ Normal()\n           x ~ Normal(m, 0.5)\n       end\ngdemo (generic function with 2 methods)\n\njulia> sample(gdemo(1.0), ESS(), 1_000) |> mean\nMean\n\n│ Row │ parameters │ mean     │\n│     │ Symbol     │ Float64  │\n├─────┼────────────┼──────────┤\n│ 1   │ m          │ 0.824853 │\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Emcee","page":"Inference","title":"Turing.Inference.Emcee","text":"Emcee(n_walkers::Int, stretch_length=2.0)\n\nAffine-invariant ensemble sampling algorithm.\n\nReference\n\nForeman-Mackey, D., Hogg, D. W., Lang, D., & Goodman, J. (2013). emcee: The MCMC Hammer. Publications of the Astronomical Society of the Pacific, 125 (925), 306. https://doi.org/10.1086/670067\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ExternalSampler","page":"Inference","title":"Turing.Inference.ExternalSampler","text":"ExternalSampler{S<:AbstractSampler,AD<:ADTypes.AbstractADType,Unconstrained}\n\nRepresents a sampler that is not an implementation of InferenceAlgorithm.\n\nThe Unconstrained type-parameter is to indicate whether the sampler requires unconstrained space.\n\nFields\n\nsampler::AbstractMCMC.AbstractSampler: the sampler to wrap\nadtype::ADTypes.AbstractADType: the automatic differentiation (AD) backend to use\n\nTuring.jl's interface for external samplers\n\nWhen implementing a new MySampler <: AbstractSampler, MySampler must first and foremost conform to the AbstractMCMC interface to work with Turing.jl's externalsampler function. In particular, it must implement:\n\nAbstractMCMC.step (the main function for taking a step in MCMC sampling; this is documented in AbstractMCMC.jl)\nTuring.Inference.getparams(::DynamicPPL.Model, external_transition): How to extract the parameters from the transition returned by your sampler (i.e., the first return value of step). There is a default implementation for this method, which is to return external_transition.θ.\n\nnote: Note\nIn a future breaking release of Turing, this is likely to change to AbstractMCMC.getparams(::DynamicPPL.Model, external_state), with no default method. Turing.Inference.getparams is technically an internal method, so the aim here is to unify the interface for samplers at a higher level.\n\nThere are a few more optional functions which you can implement to improve the integration with Turing.jl:\n\nTuring.Inference.isgibbscomponent(::MySampler): If you want your sampler to function as a component in Turing's Gibbs sampler, you should make this evaluate to true.\nTuring.Inference.requires_unconstrained_space(::MySampler): If your sampler requires unconstrained space, you should return true. This tells Turing to perform linking on the VarInfo before evaluation, and ensures that the parameter values passed to your sampler will always be in unconstrained (Euclidean) space.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Gibbs","page":"Inference","title":"Turing.Inference.Gibbs","text":"Gibbs\n\nA type representing a Gibbs sampler.\n\nConstructors\n\nGibbs needs to be given a set of pairs of variable names and samplers. Instead of a single variable name per sampler, one can also give an iterable of variables, all of which are sampled by the same component sampler.\n\nEach variable name can be given as either a Symbol or a VarName.\n\nSome examples of valid constructors are:\n\nGibbs(:x => NUTS(), :y => MH())\nGibbs(@varname(x) => NUTS(), @varname(y) => MH())\nGibbs((@varname(x), :y) => NUTS(), :z => MH())\n\nFields\n\nvarnames::NTuple{N, AbstractVector{<:AbstractPPL.VarName}} where N: varnames representing variables for each sampler\nsamplers::NTuple{N, Any} where N: samplers for each entry in varnames\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsContext","page":"Inference","title":"Turing.Inference.GibbsContext","text":"GibbsContext(target_varnames, global_varinfo, context)\n\nA context used in the implementation of the Turing.jl Gibbs sampler.\n\nThere will be one GibbsContext for each iteration of a component sampler.\n\ntarget_varnames is a a tuple of VarNames that the current component sampler is sampling. For those VarNames, GibbsContext will just pass tilde_assume calls to its child context. For other variables, their values will be fixed to the values they have in global_varinfo.\n\nFields\n\ntarget_varnames: the VarNames being sampled\n\nglobal_varinfo: a Ref to the global AbstractVarInfo object that holds values for all variables, both those fixed and those being sampled. We use a Ref because this field may need to be updated if new variables are introduced.\n\ncontext: the child context that tilde calls will eventually be passed onto.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMC","page":"Inference","title":"Turing.Inference.HMC","text":"HMC(ϵ::Float64, n_leapfrog::Int; adtype::ADTypes.AbstractADType = AutoForwardDiff())\n\nHamiltonian Monte Carlo sampler with static trajectory.\n\nArguments\n\nϵ: The leapfrog step size to use.\nn_leapfrog: The number of leapfrog steps to use.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nUsage\n\nHMC(0.05, 10)\n\nTips\n\nIf you are receiving gradient errors when using HMC, try reducing the leapfrog step size ϵ, e.g.\n\n# Original step size\nsample(gdemo([1.5, 2]), HMC(0.1, 10), 1000)\n\n# Reduced step size\nsample(gdemo([1.5, 2]), HMC(0.01, 10), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMCDA","page":"Inference","title":"Turing.Inference.HMCDA","text":"HMCDA(\n    n_adapts::Int, δ::Float64, λ::Float64; ϵ::Float64 = 0.0;\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nHamiltonian Monte Carlo sampler with Dual Averaging algorithm.\n\nUsage\n\nHMCDA(200, 0.65, 0.3)\n\nArguments\n\nn_adapts: Numbers of samples to use for adaptation.\nδ: Target acceptance rate. 65% is often recommended.\nλ: Target leapfrog length.\nϵ: Initial step size; 0 means automatically search by Turing.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nReference\n\nFor more information, please view the following paper (arXiv link):\n\nHoffman, Matthew D., and Andrew Gelman. \"The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.\" Journal of Machine Learning Research 15, no. 1 (2014): 1593-1623.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.IS","page":"Inference","title":"Turing.Inference.IS","text":"IS()\n\nImportance sampling algorithm.\n\nUsage:\n\nIS()\n\nExample:\n\n# Define a simple Normal model with unknown mean and variance.\n@model function gdemo(x)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0,sqrt.(s))\n    x[1] ~ Normal(m, sqrt.(s))\n    x[2] ~ Normal(m, sqrt.(s))\n    return s², m\nend\n\nsample(gdemo([1.5, 2]), IS(), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.InferenceAlgorithm","page":"Inference","title":"Turing.Inference.InferenceAlgorithm","text":"InferenceAlgorithm\n\nAbstract type representing an inference algorithm in Turing. Note that this is not the same as an AbstractSampler: the latter is what defines the necessary methods for actually sampling.\n\nTo create an AbstractSampler, the InferenceAlgorithm needs to be wrapped in DynamicPPL.Sampler. If sample() is called with an InferenceAlgorithm, this wrapping occurs automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.MH","page":"Inference","title":"Turing.Inference.MH","text":"MH(proposals...)\n\nConstruct a Metropolis-Hastings algorithm.\n\nThe arguments proposals can be\n\nBlank (i.e. MH()), in which case MH defaults to using the prior for each parameter as the proposal distribution.\nAn iterable of pairs or tuples mapping a Symbol to a AdvancedMH.Proposal, Distribution, or Function that returns a conditional proposal distribution.\nA covariance matrix to use as for mean-zero multivariate normal proposals.\n\nExamples\n\nThe default MH will draw proposal samples from the prior distribution using AdvancedMH.StaticProposal.\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\nchain = sample(gdemo(1.5, 2.0), MH(), 1_000)\nmean(chain)\n\nSpecifying a single distribution implies the use of static MH:\n\n# Use a static proposal for s² (which happens to be the same\n# as the prior) and a static proposal for m (note that this\n# isn't a random walk proposal).\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => InverseGamma(2, 3),\n        :m => Normal(0, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nSpecifying explicit proposals using the AdvancedMH interface:\n\n# Use a static proposal for s² and random walk with proposal\n# standard deviation of 0.25 for m.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => AdvancedMH.StaticProposal(InverseGamma(2,3)),\n        :m => AdvancedMH.RandomWalkProposal(Normal(0, 0.25))\n    ),\n    1_000\n)\nmean(chain)\n\nUsing a custom function to specify a conditional distribution:\n\n# Use a static proposal for s and and a conditional proposal for m,\n# where the proposal is centered around the current sample.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => InverseGamma(2, 3),\n        :m => x -> Normal(x, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nProviding a covariance matrix will cause MH to perform random-walk sampling in the transformed space with proposals drawn from a multivariate normal distribution. The provided matrix must be positive semi-definite and square:\n\n# Providing a custom variance-covariance matrix\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        [0.25 0.05;\n         0.05 0.50]\n    ),\n    1_000\n)\nmean(chain)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.MHState","page":"Inference","title":"Turing.Inference.MHState","text":"MHState(varinfo::AbstractVarInfo, logjoint_internal::Real)\n\nState for Metropolis-Hastings sampling.\n\nvarinfo must have the correct parameters set inside it, but its other fields (e.g. accumulators, which track logp) can in general be missing or incorrect.\n\nlogjoint_internal is the log joint probability of the model, evaluated using the parameters and linking status of varinfo. It should be equal to DynamicPPL.getlogjoint_internal(varinfo). This information is returned by the MH sampler so we store this here to avoid re-evaluating the model unnecessarily.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.NUTS","page":"Inference","title":"Turing.Inference.NUTS","text":"NUTS(n_adapts::Int, δ::Float64; max_depth::Int=10, Δ_max::Float64=1000.0, init_ϵ::Float64=0.0; adtype::ADTypes.AbstractADType=AutoForwardDiff()\n\nNo-U-Turn Sampler (NUTS) sampler.\n\nUsage:\n\nNUTS()            # Use default NUTS configuration.\nNUTS(1000, 0.65)  # Use 1000 adaption steps, and target accept ratio 0.65.\n\nArguments:\n\nn_adapts::Int : The number of samples to use with adaptation.\nδ::Float64 : Target acceptance rate for dual averaging.\nmax_depth::Int : Maximum doubling tree depth.\nΔ_max::Float64 : Maximum divergence during doubling tree.\ninit_ϵ::Float64 : Initial step size; 0 means automatically searching using a heuristic procedure.\nadtype::ADTypes.AbstractADType : The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG","page":"Inference","title":"Turing.Inference.PG","text":"struct PG{R} <: Turing.Inference.ParticleInference\n\nParticle Gibbs sampler.\n\nFields\n\nnparticles::Int64: Number of particles.\nresampler::Any: Resampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG-Tuple{Int64}","page":"Inference","title":"Turing.Inference.PG","text":"PG(n, [resampler = AdvancedPS.ResampleWithESSThreshold()])\nPG(n, [resampler = AdvancedPS.resample_systematic, ]threshold)\n\nCreate a Particle Gibbs sampler of type PG with n particles.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.PolynomialStepsize-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Inference","title":"Turing.Inference.PolynomialStepsize","text":"PolynomialStepsize(a[, b=0, γ=0.55])\n\nCreate a polynomially decaying stepsize function.\n\nAt iteration t, the step size is\n\na (b + t)^-γ\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.Prior","page":"Inference","title":"Turing.Inference.Prior","text":"Prior()\n\nAlgorithm for sampling from the prior.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ProduceLogLikelihoodAccumulator","page":"Inference","title":"Turing.Inference.ProduceLogLikelihoodAccumulator","text":"ProduceLogLikelihoodAccumulator{T<:Real} <: AbstractAccumulator\n\nExactly like LogLikelihoodAccumulator, but calls Libtask.produce on change of value.\n\nFields\n\nlogp::Real: the scalar log likelihood value\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.RepeatSampler","page":"Inference","title":"Turing.Inference.RepeatSampler","text":"RepeatSampler <: AbstractMCMC.AbstractSampler\n\nA RepeatSampler is a container for a sampler and a number of times to repeat it.\n\nFields\n\nsampler: The sampler to repeat\nnum_repeat: The number of times to repeat the sampler\n\nExamples\n\nrepeated_sampler = RepeatSampler(sampler, 10)\nAbstractMCMC.step(rng, model, repeated_sampler) # take 10 steps of `sampler`\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC{AD}\n\nStochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nFields\n\nlearning_rate::Real\nmomentum_decay::Real\nadtype::Any\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC-Tuple{}","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC(;\n    learning_rate::Real,\n    momentum_decay::Real,\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nCreate a Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SGLD","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nFields\n\nstepsize::Any: Step size function.\nadtype::Any\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGLD-Tuple{}","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD(;\n    stepsize = PolynomialStepsize(0.01),\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nBy default, a polynomially decaying stepsize is used.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\nSee also: PolynomialStepsize\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SMC","page":"Inference","title":"Turing.Inference.SMC","text":"struct SMC{R} <: Turing.Inference.ParticleInference\n\nSequential Monte Carlo sampler.\n\nFields\n\nresampler::Any\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SMC-Tuple{}","page":"Inference","title":"Turing.Inference.SMC","text":"SMC([resampler = AdvancedPS.ResampleWithESSThreshold()])\nSMC([resampler = AdvancedPS.resample_systematic, ]threshold)\n\nCreate a sequential Monte Carlo sampler of type SMC.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.dist_val_tuple-Tuple{DynamicPPL.Sampler{<:MH}, Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta}","page":"Inference","title":"Turing.Inference.dist_val_tuple","text":"dist_val_tuple(spl::Sampler{<:MH}, vi::VarInfo)\n\nReturn two NamedTuples.\n\nThe first NamedTuple has symbols as keys and distributions as values. The second NamedTuple has model symbols as keys and their stored values as values.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.externalsampler-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.externalsampler","text":"externalsampler(sampler::AbstractSampler; adtype=AutoForwardDiff(), unconstrained=true)\n\nWrap a sampler so it can be used as an inference algorithm.\n\nArguments\n\nsampler::AbstractSampler: The sampler to wrap.\n\nKeyword Arguments\n\nadtype::ADTypes.AbstractADType=ADTypes.AutoForwardDiff(): The automatic differentiation (AD) backend to use.\nunconstrained::Bool=true: Whether the sampler requires unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.get_trace_local_rng_maybe-Tuple{Random.AbstractRNG}","page":"Inference","title":"Turing.Inference.get_trace_local_rng_maybe","text":"get_trace_local_varinfo_maybe(rng::Random.AbstractRNG)\n\nGet the Trace local rng if one exists.\n\nIf executed within a TapedTask, return the rng stored in the \"taped globals\" of the task, otherwise return vi.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.get_trace_local_varinfo_maybe-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.get_trace_local_varinfo_maybe","text":"get_trace_local_varinfo_maybe(vi::AbstractVarInfo)\n\nGet the Trace local varinfo if one exists.\n\nIf executed within a TapedTask, return the varinfo stored in the \"taped globals\" of the task, otherwise return vi.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.getparams-Tuple{DynamicPPL.Model, Any}","page":"Inference","title":"Turing.Inference.getparams","text":"Turing.Inference.getparams(model::DynamicPPL.Model, t::Any)\n\nReturn a vector of parameter values from the given sampler transition t (i.e., the first return value of AbstractMCMC.step). By default, returns the t.θ field.\n\nnote: Note\nThis method only needs to be implemented for external samplers. It will be\n\nremoved in future releases and replaced with AbstractMCMC.getparams.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.getparams-Tuple{DynamicPPL.Model, DynamicPPL.VarInfo}","page":"Inference","title":"Turing.Inference.getparams","text":"Turing.Inference.getparams(model::DynamicPPL.Model, t::AbstractVarInfo)\n\nReturn a key-value map of parameters from the varinfo.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_initialstep_recursive","page":"Inference","title":"Turing.Inference.gibbs_initialstep_recursive","text":"Take the first step of MCMC for the first component sampler, and call the same function recursively on the remaining samplers, until no samplers remain. Return the global VarInfo and a tuple of initial states for all component samplers.\n\nThe step_function argument should always be either AbstractMCMC.step or AbstractMCMC.step_warmup.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.gibbs_step_recursive","page":"Inference","title":"Turing.Inference.gibbs_step_recursive","text":"Run a Gibbs step for the first varname/sampler/state tuple, and recursively call the same function on the tail, until there are no more samplers left.\n\nThe step_function argument should always be either AbstractMCMC.step or AbstractMCMC.step_warmup.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.group_varnames_by_symbol-Tuple{Any}","page":"Inference","title":"Turing.Inference.group_varnames_by_symbol","text":"group_varnames_by_symbol(vns)\n\nGroup the varnames by their symbol.\n\nArguments\n\nvns: Iterable of VarName.\n\nReturns\n\nOrderedDict{Symbol, Vector{VarName}}: A dictionary mapping symbol to a vector of varnames.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.initial_varinfo-NTuple{4, Any}","page":"Inference","title":"Turing.Inference.initial_varinfo","text":"Initialise a VarInfo for the Gibbs sampler.\n\nThis is straight up copypasta from DynamicPPL's src/sampler.jl. It is repeated here to support calling both step and stepwarmup as the initial step. DynamicPPL initialstep is incompatible with stepwarmup.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.isgibbscomponent-Tuple{Turing.Inference.InferenceAlgorithm}","page":"Inference","title":"Turing.Inference.isgibbscomponent","text":"isgibbscomponent(alg::Union{InferenceAlgorithm, AbstractMCMC.AbstractSampler})\n\nReturn a boolean indicating whether alg is a valid component for a Gibbs sampler.\n\nDefaults to false if no method has been defined for a particular algorithm type.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.make_conditional-Tuple{DynamicPPL.Model, AbstractVector{<:AbstractPPL.VarName}, Any}","page":"Inference","title":"Turing.Inference.make_conditional","text":"make_conditional(model, target_variables, varinfo)\n\nReturn a new, conditioned model for a component of a Gibbs sampler.\n\nArguments\n\nmodel::DynamicPPL.Model: The model to condition.\ntarget_variables::AbstractVector{<:VarName}: The target variables of the component\n\nsampler. These will not be conditioned.\n\nvarinfo::DynamicPPL.AbstractVarInfo: Values for all variables in the model. All the\n\nvalues in varinfo but not in target_variables will be conditioned to the values they have in varinfo.\n\nReturns\n\nA new model with the variables not in target_variables conditioned.\nThe GibbsContext object that will be used to condition the variables. This is necessary\n\nbecause evaluation can mutate its global_varinfo field, which we need to access later.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.match_linking!!-Tuple{Any, Any, Any}","page":"Inference","title":"Turing.Inference.match_linking!!","text":"match_linking!!(varinfo_local, prev_state_local, model)\n\nMake sure the linked/invlinked status of varinfo_local matches that of the previous state for this sampler. This is relevant when multiple samplers are sampling the same variables, and one might need it to be linked while the other doesn't.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.mh_accept-Tuple{Real, Real, Real}","page":"Inference","title":"Turing.Inference.mh_accept","text":"mh_accept(logp_current::Real, logp_proposal::Real, log_proposal_ratio::Real)\n\nDecide if a proposal x with log probability log p(x) = logp_proposal and log proposal ratio log k(x x) - log k(x x) = log_proposal_ratio in a Metropolis-Hastings algorithm with Markov kernel k(x_t x_t+1) and current state x with log probability log p(x) = logp_current is accepted by evaluating the Metropolis-Hastings acceptance criterion\n\nlog U leq log p(x) - log p(x) + log k(x x) - log k(x x)\n\nfor a uniform random number U in 0 1).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.requires_unconstrained_space-Union{Tuple{Turing.Inference.ExternalSampler{<:Any, <:Any, Unconstrained}}, Tuple{Unconstrained}} where Unconstrained","page":"Inference","title":"Turing.Inference.requires_unconstrained_space","text":"requires_unconstrained_space(sampler::ExternalSampler)\n\nReturn true if the sampler requires unconstrained space, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_all_del!-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.set_all_del!","text":"set_all_del!(vi::AbstractVarInfo)\n\nSet the \"del\" flag for all variables in the VarInfo vi, thus marking them for resampling.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_namedtuple!-Tuple{Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta, NamedTuple}","page":"Inference","title":"Turing.Inference.set_namedtuple!","text":"set_namedtuple!(vi::VarInfo, nt::NamedTuple)\n\nPlaces the values of a NamedTuple into the relevant places of a VarInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_trace_local_varinfo_maybe-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.set_trace_local_varinfo_maybe","text":"set_trace_local_varinfo_maybe(vi::AbstractVarInfo)\n\nSet the Trace local varinfo if executing within a Trace. Return nothing.\n\nIf executed within a TapedTask, set the varinfo stored in the \"taped globals\" of the task. Otherwise do nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.setparams_varinfo!!-Tuple{Any, DynamicPPL.Sampler, Any, DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.setparams_varinfo!!","text":"setparams_varinfo!!(model, sampler::Sampler, state, params::AbstractVarInfo)\n\nA lot like AbstractMCMC.setparams!!, but instead of taking a vector of parameters, takes an AbstractVarInfo object. Also takes the sampler as an argument. By default, falls back to AbstractMCMC.setparams!!(model, state, params[:]).\n\nmodel is typically a DynamicPPL.Model, but can also be e.g. an AbstractMCMC.LogDensityModel.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.unset_all_del!-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.unset_all_del!","text":"unset_all_del!(vi::AbstractVarInfo)\n\nUnset the \"del\" flag for all variables in the VarInfo vi, thus preventing them from being resampled.\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Module-wide-re-exports","page":"API","title":"Module-wide re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Turing.jl directly re-exports the entire public API of the following packages:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Distributions.jl\nMCMCChains.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Please see the individual packages for their documentation.","category":"page"},{"location":"api/#Individual-exports-and-re-exports","page":"API","title":"Individual exports and re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In this API documentation, for the sake of clarity, we have listed the module that actually defines each of the exported symbols. Note, however, that all of the following symbols are exported unqualified by Turing. That means, for example, you can just write","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Turing\n\n@model function my_model() end\n\nsample(my_model(), Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"instead of","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.@model function my_model() end\n\nsample(my_model(), Turing.Inference.Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"even though Prior() is actually defined in the Turing.Inference module and @model in the DynamicPPL package.","category":"page"},{"location":"api/#Modelling","page":"API","title":"Modelling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\n@model DynamicPPL.@model Define a probabilistic model\n@varname AbstractPPL.@varname Generate a VarName from a Julia expression\nto_submodel DynamicPPL.to_submodel Define a submodel\nprefix DynamicPPL.prefix Prefix all variable names in a model with a given VarName\nLogDensityFunction DynamicPPL.LogDensityFunction A struct containing all information about how to evaluate a model. Mostly for advanced users\n@addlogprob! DynamicPPL.@addlogprob! Add arbitrary log-probability terms during model evaluation","category":"page"},{"location":"api/#Inference","page":"API","title":"Inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nsample StatsBase.sample Sample from a model\nMCMCThreads AbstractMCMC.MCMCThreads Run MCMC using multiple threads\nMCMCDistributed AbstractMCMC.MCMCDistributed Run MCMC using multiple processes\nMCMCSerial AbstractMCMC.MCMCSerial Run MCMC using without parallelism","category":"page"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nPrior Turing.Inference.Prior Sample from the prior distribution\nMH Turing.Inference.MH Metropolis–Hastings\nEmcee Turing.Inference.Emcee Affine-invariant ensemble sampler\nESS Turing.Inference.ESS Elliptical slice sampling\nGibbs Turing.Inference.Gibbs Gibbs sampling\nHMC Turing.Inference.HMC Hamiltonian Monte Carlo\nSGLD Turing.Inference.SGLD Stochastic gradient Langevin dynamics\nSGHMC Turing.Inference.SGHMC Stochastic gradient Hamiltonian Monte Carlo\nPolynomialStepsize Turing.Inference.PolynomialStepsize Returns a function which generates polynomially decaying step sizes\nHMCDA Turing.Inference.HMCDA Hamiltonian Monte Carlo with dual averaging\nNUTS Turing.Inference.NUTS No-U-Turn Sampler\nIS Turing.Inference.IS Importance sampling\nSMC Turing.Inference.SMC Sequential Monte Carlo\nPG Turing.Inference.PG Particle Gibbs\nCSMC Turing.Inference.CSMC The same as PG\nRepeatSampler Turing.Inference.RepeatSampler A sampler that runs multiple times on the same variable\nexternalsampler Turing.Inference.externalsampler Wrap an external sampler for use in Turing","category":"page"},{"location":"api/#Variational-inference","page":"API","title":"Variational inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See the docs of AdvancedVI.jl for detailed usage and the variational inference tutorial for a basic walkthrough.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nvi Turing.vi Perform variational inference\nq_locationscale Turing.Variational.q_locationscale Find a numerically non-degenerate initialization for a location-scale variational family\nq_meanfield_gaussian Turing.Variational.q_meanfield_gaussian Find a numerically non-degenerate initialization for a mean-field Gaussian family\nq_fullrank_gaussian Turing.Variational.q_fullrank_gaussian Find a numerically non-degenerate initialization for a full-rank Gaussian family","category":"page"},{"location":"api/#Automatic-differentiation-types","page":"API","title":"Automatic differentiation types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These are used to specify the automatic differentiation backend to use. See the AD guide for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nAutoForwardDiff ADTypes.AutoForwardDiff ForwardDiff.jl backend\nAutoReverseDiff ADTypes.AutoReverseDiff ReverseDiff.jl backend\nAutoMooncake ADTypes.AutoMooncake Mooncake.jl backend","category":"page"},{"location":"api/#Debugging","page":"API","title":"Debugging","text":"","category":"section"},{"location":"api/#Turing.setprogress!","page":"API","title":"Turing.setprogress!","text":"setprogress!(progress::Bool)\n\nEnable progress logging in Turing if progress is true, and disable it otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Distributions","page":"API","title":"Distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These distributions are defined in Turing.jl, but not in Distributions.jl.","category":"page"},{"location":"api/#Turing.Flat","page":"API","title":"Turing.Flat","text":"Flat()\n\nThe flat distribution is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = 1\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.FlatPos","page":"API","title":"Turing.FlatPos","text":"FlatPos(l::Real)\n\nThe positive flat distribution with real-valued parameter l is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = begincases\n0  textif  x leq l \n1  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.BinomialLogit","page":"API","title":"Turing.BinomialLogit","text":"BinomialLogit(n, logitp)\n\nThe Binomial distribution with logit parameterization characterizes the number of successes in a sequence of independent trials.\n\nIt has two parameters: n, the number of trials, and logitp, the logit of the probability of success in an individual trial, with the distribution\n\nP(X = k) = n choose k(textlogistic(logitp))^k (1 - textlogistic(logitp))^n-k quad text for  k = 012 ldots n\n\nSee also: Binomial\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.OrderedLogistic","page":"API","title":"Turing.OrderedLogistic","text":"OrderedLogistic(η, c::AbstractVector)\n\nThe ordered logistic distribution with real-valued parameter η and cutpoints c has the probability mass function\n\nP(X = k) = begincases\n    1 - textlogistic(eta - c_1)  textif  k = 1 \n    textlogistic(eta - c_k-1) - textlogistic(eta - c_k)  textif  1  k  K \n    textlogistic(eta - c_K-1)  textif  k = K\nendcases\n\nwhere K = length(c) + 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.LogPoisson","page":"API","title":"Turing.LogPoisson","text":"LogPoisson(logλ)\n\nThe Poisson distribution with logarithmic parameterization of the rate parameter describes the number of independent events occurring within a unit time interval, given the average rate of occurrence exp(loglambda).\n\nThe distribution has the probability mass function\n\nP(X = k) = frace^k cdot loglambdak e^-e^loglambda quad text for  k = 012ldots\n\nSee also: Poisson\n\n\n\n\n\n","category":"type"},{"location":"api/#Tools-to-work-with-distributions","page":"API","title":"Tools to work with distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nI LinearAlgebra.I Identity matrix\nfilldist DistributionsAD.filldist Create a product distribution from a distribution and integers\narraydist DistributionsAD.arraydist Create a product distribution from an array of distributions\nNamedDist DynamicPPL.NamedDist A distribution that carries the name of the variable","category":"page"},{"location":"api/#Predictions","page":"API","title":"Predictions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\npredict StatsAPI.predict Generate samples from posterior predictive distribution","category":"page"},{"location":"api/#Querying-model-probabilities-and-quantities","page":"API","title":"Querying model probabilities and quantities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Please see the generated quantities and probability interface guides for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nreturned DynamicPPL.returned Calculate additional quantities defined in a model\npointwise_loglikelihoods DynamicPPL.pointwise_loglikelihoods Compute log likelihoods for each sample in a chain\nlogprior DynamicPPL.logprior Compute log prior probability\nlogjoint DynamicPPL.logjoint Compute log joint probability\ncondition AbstractPPL.condition Condition a model on data\ndecondition AbstractPPL.decondition Remove conditioning on data\nconditioned DynamicPPL.conditioned Return the conditioned values of a model\nfix DynamicPPL.fix Fix the value of a variable\nunfix DynamicPPL.unfix Unfix the value of a variable\nOrderedDict OrderedCollections.OrderedDict An ordered dictionary","category":"page"},{"location":"api/#Point-estimates","page":"API","title":"Point estimates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See the mode estimation tutorial for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nmaximum_a_posteriori Turing.Optimisation.maximum_a_posteriori Find a MAP estimate for a model\nmaximum_likelihood Turing.Optimisation.maximum_likelihood Find a MLE estimate for a model\nMAP Turing.Optimisation.MAP Type to use with Optim.jl for MAP estimation\nMLE Turing.Optimisation.MLE Type to use with Optim.jl for MLE estimation","category":"page"},{"location":"#Turing.jl","page":"Home","title":"Turing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This site contains the API documentation for the identifiers exported by Turing.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are looking for usage examples and guides, please visit https://turinglang.org/docs.","category":"page"},{"location":"api/Variational/#API:-Turing.Variational","page":"Variational ","title":"API: Turing.Variational","text":"","category":"section"},{"location":"api/Variational/#Turing.Variational.q_fullrank_gaussian-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_fullrank_gaussian","text":"q_fullrank_gaussian(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:LowerTriangular} = nothing,\n    kwargs...\n)\n\nFind a numerically non-degenerate Gaussian q with a scale with full-rank factors (traditionally referred to as a \"full-rank family\") for approximating the target model.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\n\nThe remaining keyword arguments are passed to q_locationscale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_initialize_scale-Tuple{Random.AbstractRNG, DynamicPPL.Model, AbstractVector, AbstractMatrix, UnivariateDistribution}","page":"Variational ","title":"Turing.Variational.q_initialize_scale","text":"q_initialize_scale(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model,\n    location::AbstractVector,\n    scale::AbstractMatrix,\n    basedist::Distributions.UnivariateDistribution;\n    num_samples::Int = 10,\n    num_max_trials::Int = 10,\n    reduce_factor::Real = one(eltype(scale)) / 2\n)\n\nGiven an initial location-scale distribution q formed by location, scale, and basedist, shrink scale until the expectation of log-densities of model taken over q are finite. If the log-densities are not finite even after num_max_trials, throw an error.\n\nFor reference, a location-scale distribution q formed by location, scale, and basedist is a distribution where its sampling process z sim q can be represented as\n\nu = rand(basedist, d)\nz = scale * u + location\n\nArguments\n\nmodel: The target DynamicPPL.Model.\nlocation: The location parameter of the initialization.\nscale: The scale parameter of the initialization.\nbasedist: The base distribution of the location-scale family.\n\nKeyword Arguments\n\nnum_samples: Number of samples used to compute the average log-density at each trial.\nnum_max_trials: Number of trials until throwing an error.\nreduce_factor: Factor for shrinking the scale. After n trials, the scale is then scale*reduce_factor^n.\n\nReturns\n\nscale_adj: The adjusted scale matrix matching the type of scale.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_locationscale-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_locationscale","text":"q_locationscale(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:Diagonal,<:LowerTriangular} = nothing,\n    meanfield::Bool = true,\n    basedist::Distributions.UnivariateDistribution = Normal()\n)\n\nFind a numerically non-degenerate variational distribution q for approximating the  target model within the location-scale variational family formed by the type of scale and basedist.\n\nThe distribution can be manually specified by setting location, scale, and basedist. Otherwise, it chooses a standard Gaussian by default. Whether the default choice is used or not, the scale may be adjusted via q_initialize_scale so that the log-densities of model are finite over the samples from q. If meanfield is set as true, the scale of q is restricted to be a diagonal matrix and only the diagonal of scale is used.\n\nFor reference, a location-scale distribution q formed by location, scale, and basedist is a distribution where its sampling process z sim q can be represented as\n\nu = rand(basedist, d)\nz = scale * u + location\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\nmeanfield: Whether to use the mean-field approximation. If true, scale is converted into a Diagonal matrix. Otherwise, it is converted into a LowerTriangular matrix.\nbasedist: The base distribution of the location-scale family.\n\nThe remaining keywords are passed to q_initialize_scale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_meanfield_gaussian-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_meanfield_gaussian","text":"q_meanfield_gaussian(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:Diagonal} = nothing,\n    kwargs...\n)\n\nFind a numerically non-degenerate mean-field Gaussian q for approximating the  target model.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\n\nThe remaining keyword arguments are passed to q_locationscale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.vi-Tuple{Random.AbstractRNG, DynamicPPL.Model, Any, Int64}","page":"Variational ","title":"Turing.Variational.vi","text":"vi(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    q,\n    n_iterations::Int;\n    objective::AdvancedVI.AbstractVariationalObjective = AdvancedVI.RepGradELBO(\n        10; entropy = AdvancedVI.ClosedFormEntropyZeroGradient()\n    ),\n    show_progress::Bool = Turing.PROGRESS[],\n    optimizer::Optimisers.AbstractRule = AdvancedVI.DoWG(),\n    averager::AdvancedVI.AbstractAverager = AdvancedVI.PolynomialAveraging(),\n    operator::AdvancedVI.AbstractOperator = AdvancedVI.ProximalLocationScaleEntropy(),\n    adtype::ADTypes.AbstractADType = Turing.DEFAULT_ADTYPE,\n    kwargs...\n)\n\nApproximating the target model via variational inference by optimizing objective with the initialization q. This is a thin wrapper around AdvancedVI.optimize.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\nq: The initial variational approximation.\nn_iterations: Number of optimization steps.\n\nKeyword Arguments\n\nobjective: Variational objective to be optimized.\nshow_progress: Whether to show the progress bar.\noptimizer: Optimization algorithm.\naverager: Parameter averaging strategy.\noperator: Operator applied after each optimization step.\nadtype: Automatic differentiation backend.\n\nSee the docs of AdvancedVI.optimize for additional keyword arguments.\n\nReturns\n\nq: Variational distribution formed by the last iterate of the optimization run.\nq_avg: Variational distribution formed by the averaged iterates according to averager.\nstate: Collection of states used for optimization. This can be used to resume from a past call to vi.\ninfo: Information generated during the optimization run.\n\n\n\n\n\n","category":"method"}]
}
