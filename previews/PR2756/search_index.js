var documenterSearchIndex = {"docs":
[{"location":"api/Optimisation/#API:-Turing.Optimisation","page":"Optimisation","title":"API: Turing.Optimisation","text":"","category":"section"},{"location":"api/Optimisation/#DynamicPPL.InitFromParams","page":"Optimisation","title":"DynamicPPL.InitFromParams","text":"InitFromParams(\n    m::ModeResult,\n    fallback::Union{AbstractInitStrategy,Nothing}=InitFromPrior()\n)\n\nInitialize a model from the parameters stored in a ModeResult. The fallback is used if some parameters are missing from the ModeResult.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#SciMLBase.OptimizationProblem-Tuple{Turing.Optimisation.OptimLogDensity, AbstractVector, Any, Any}","page":"Optimisation","title":"SciMLBase.OptimizationProblem","text":"OptimizationProblem(log_density::OptimLogDensity, initial_params::AbstractVector, adtype, constraints)\n\nCreate an OptimizationProblem for the objective function defined by log_density.\n\nNote that the adtype parameter here overrides any adtype parameter the OptimLogDensity was constructed with.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.MAP","page":"Optimisation","title":"Turing.Optimisation.MAP","text":"MAP <: ModeEstimator\n\nConcrete type for maximum a posteriori estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.MLE","page":"Optimisation","title":"Turing.Optimisation.MLE","text":"MLE <: ModeEstimator\n\nConcrete type for maximum likelihood estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimationConstraints","page":"Optimisation","title":"Turing.Optimisation.ModeEstimationConstraints","text":"ModeEstimationConstraints\n\nA struct that holds constraints for mode estimation problems.\n\nThe fields are the same as possible constraints supported by the Optimization.jl: ub and lb specify lower and upper bounds of box constraints. cons is a function that takes the parameters of the model and returns a list of derived quantities, which are then constrained by the lower and upper bounds set by lcons and ucons. We refer to these as generic constraints. Please see the documentation of Optimization.jl for more details.\n\nAny of the fields can be nothing, disabling the corresponding constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimator","page":"Optimisation","title":"Turing.Optimisation.ModeEstimator","text":"ModeEstimator\n\nAn abstract type to mark whether mode estimation is to be done with maximum a posteriori (MAP) or maximum likelihood estimation (MLE).\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult{\n    V<:NamedArrays.NamedArray,\n    O<:Any,\n    M<:OptimLogDensity,\n    P<:AbstractDict{<:VarName,<:Any}\n    E<:ModeEstimator,\n}\n\nA wrapper struct to store various results from a MAP or MLE estimation.\n\nFields\n\nvalues::NamedArrays.NamedArray: A vector with the resulting point estimates.\noptim_result::Any: The stored optimiser results.\nlp::Float64: The final log likelihood or log joint, depending on whether MAP or MLE was run.\nf::Turing.Optimisation.OptimLogDensity: The evaluation function used to calculate the output.\nparams::AbstractDict{<:AbstractPPL.VarName}: Dictionary of parameter values\nlinked::Bool: Whether the optimization was done in a transformed space.\nestimator::Turing.Optimisation.ModeEstimator: The type of mode estimation (MAP or MLE).\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult-Tuple{Turing.Optimisation.OptimLogDensity, SciMLBase.OptimizationSolution, Bool, Turing.Optimisation.ModeEstimator}","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult(\n    log_density::OptimLogDensity,\n    solution::SciMLBase.OptimizationSolution,\n    linked::Bool,\n    estimator::ModeEstimator,\n)\n\nCreate a ModeResult for a given log_density objective and a solution given by solve. The linked argument indicates whether the optimization was done in a transformed space.\n\nOptimization.solve returns its own result type. This function converts that into the richer format of ModeResult. It also takes care of transforming them back to the original parameter space in case the optimization was done in a transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity{L<:DynamicPPL.LogDensityFunction}\n\nA struct that represents a log-density function, which can be used with Optimization.jl. This is a thin wrapper around DynamicPPL.LogDensityFunction: the main difference is that the log-density is negated (because Optimization.jl performs minimisation, and we usually want to maximise the log-density).\n\nAn OptimLogDensity does not, in itself, obey the LogDensityProblems.jl interface. Thus, if you want to calculate the log density of its contents at the point z, you should manually call LogDensityProblems.logdensity(f.ldf, z), instead of LogDensityProblems.logdensity(f, z).\n\nHowever, because Optimization.jl requires the objective function to be callable, you can also call f(z) directly to get the negative log density at z.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{AbstractVector}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"(f::OptimLogDensity)(z)\n(f::OptimLogDensity)(z, _)\n\nEvaluate the negative log probability density at the array z. Which kind of probability density is evaluated depends on the getlogdensity function used to construct the underlying LogDensityFunction (e.g., DynamicPPL.getlogjoint for MAP estimation, or DynamicPPL.getloglikelihood for MLE).\n\nAny second argument is ignored. The two-argument method only exists to match the interface required by Optimization.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Base.get-Tuple{Turing.Optimisation.ModeResult, AbstractVector{Symbol}}","page":"Optimisation","title":"Base.get","text":"Base.get(m::ModeResult, var_symbol::Symbol)\nBase.get(m::ModeResult, var_symbols::AbstractVector{Symbol})\n\nReturn the values of all the variables with the symbol(s) var_symbol in the mode result m. The return value is a NamedTuple with var_symbols as the key(s). The second argument should be either a Symbol or a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#StatsAPI.coeftable-Tuple{Turing.Optimisation.ModeResult}","page":"Optimisation","title":"StatsAPI.coeftable","text":"StatsBase.coeftable(m::ModeResult; level::Real=0.95, numerrors_warnonly::Bool=true)\n\nReturn a table with coefficients and related statistics of the model. level determines the level for confidence intervals (by default, 95%).\n\nIn case the numerrors_warnonly argument is true (the default) numerical errors encountered during the computation of the standard errors will be caught and reported in an extra \"Error notes\" column.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.estimate_mode","page":"Optimisation","title":"Turing.Optimisation.estimate_mode","text":"estimate_mode(\n    model::DynamicPPL.Model,\n    estimator::ModeEstimator,\n    [solver];\n    kwargs...\n)\n\nFind the mode of the probability distribution of a model.\n\nUnder the hood this function calls Optimization.solve.\n\nArguments\n\nmodel::DynamicPPL.Model: The model for which to estimate the mode.\nestimator::ModeEstimator: Can be either MLE() for maximum likelihood estimation or   MAP() for maximum a posteriori estimation.\nsolver=nothing. The optimization algorithm to use. Optional. Can be any solver   recognised by Optimization.jl. If omitted a default solver is used: LBFGS, or IPNewton   if non-box constraints are present.\n\nKeyword arguments\n\ncheck_model::Bool=true: If true, the model is checked for errors before   optimisation begins.\ninitial_params::Union{AbstractVector,Nothing}=nothing: Initial value for the   optimization. Optional, unless non-box constraints are specified. If omitted it is   generated by either sampling from the prior distribution or uniformly from the box   constraints, if any.\nadtype::AbstractADType=AutoForwardDiff(): The automatic differentiation type to use.\nKeyword arguments lb, ub, cons, lcons, and ucons define constraints for the   optimization problem. Please see ModeEstimationConstraints for more details.\nAny extra keyword arguments are passed to Optimization.solve.\n\n\n\n\n\n","category":"function"},{"location":"api/Optimisation/#Turing.Optimisation.generate_initial_params-Tuple{DynamicPPL.Model, Any, Any}","page":"Optimisation","title":"Turing.Optimisation.generate_initial_params","text":"generate_initial_params(model::DynamicPPL.Model, initial_params, constraints)\n\nGenerate an initial value for the optimization problem.\n\nIf initial_params is not nothing, a copy of it is returned. Otherwise initial parameter values are generated either by sampling from the prior (if no constraints are present) or uniformly from the box constraints. If generic constraints are set, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_a_posteriori-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_a_posteriori","text":"maximum_a_posteriori(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum a posteriori estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MAP() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_likelihood-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_likelihood","text":"maximum_likelihood(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum likelihood estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MLE() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#API:-Turing.Inference","page":"Inference","title":"API: Turing.Inference","text":"","category":"section"},{"location":"api/Inference/#Turing.Inference.CSMC","page":"Inference","title":"Turing.Inference.CSMC","text":"CSMC(...)\n\nEquivalent to PG.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ESS","page":"Inference","title":"Turing.Inference.ESS","text":"ESS\n\nElliptical slice sampling algorithm.\n\nExamples\n\njulia> @model function gdemo(x)\n           m ~ Normal()\n           x ~ Normal(m, 0.5)\n       end\ngdemo (generic function with 2 methods)\n\njulia> sample(gdemo(1.0), ESS(), 1_000) |> mean\nMean\n\n│ Row │ parameters │ mean     │\n│     │ Symbol     │ Float64  │\n├─────┼────────────┼──────────┤\n│ 1   │ m          │ 0.824853 │\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Emcee","page":"Inference","title":"Turing.Inference.Emcee","text":"Emcee(n_walkers::Int, stretch_length=2.0)\n\nAffine-invariant ensemble sampling algorithm.\n\nReference\n\nForeman-Mackey, D., Hogg, D. W., Lang, D., & Goodman, J. (2013). emcee: The MCMC Hammer. Publications of the Astronomical Society of the Pacific, 125 (925), 306. https://doi.org/10.1086/670067\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ExternalSampler","page":"Inference","title":"Turing.Inference.ExternalSampler","text":"ExternalSampler{Unconstrained,S<:AbstractSampler,AD<:ADTypes.AbstractADType}\n\nRepresents a sampler that does not have a custom implementation of AbstractMCMC.step(rng, ::DynamicPPL.Model, spl).\n\nThe Unconstrained type-parameter is to indicate whether the sampler requires unconstrained space.\n\nFields\n\nsampler::AbstractMCMC.AbstractSampler: the sampler to wrap\nadtype::ADTypes.AbstractADType: the automatic differentiation (AD) backend to use\n\nTuring.jl's interface for external samplers\n\nIf you implement a new MySampler <: AbstractSampler and want it to work with Turing.jl models, there are two options:\n\nDirectly implement the AbstractMCMC.step methods for DynamicPPL.Model. That is to say, implement AbstractMCMC.step(rng::Random.AbstractRNG, model::DynamicPPL.Model, sampler::MySampler; kwargs...) and related methods. This is the most powerful option and is what Turing.jl's in-house samplers do. Implementing this means that you can directly call sample(model, MySampler(), N).\nImplement a generic AbstractMCMC.step method for AbstractMCMC.LogDensityModel (the same signature as above except that model::AbstractMCMC.LogDensityModel). This struct wraps an object that obeys the LogDensityProblems.jl interface, so your step implementation does not need to know anything about Turing.jl or DynamicPPL.jl. To use this with Turing.jl, you will need to wrap your sampler: sample(model, externalsampler(MySampler()), N).\n\nThis section describes the latter.\n\nMySampler must implement the following methods:\n\nAbstractMCMC.step (the main function for taking a step in MCMC sampling; this is documented in AbstractMCMC.jl). This function must return a tuple of two elements, a 'transition' and a 'state'.\nAbstractMCMC.getparams(external_state): How to extract the parameters from the state returned by your sampler (i.e., the second return value of step). For your sampler to work with Turing.jl, this function should return a Vector of parameter values. Note that this function does not need to perform any linking or unlinking; Turing.jl will take care of this for you. You should return the parameters exactly as your sampler sees them.\nAbstractMCMC.getstats(external_state): Extract sampler statistics corresponding to this iteration from the state returned by your sampler (i.e., the second return value of step). For your sampler to work with Turing.jl, this function should return a NamedTuple. If there are no statistics to return, return NamedTuple().\nNote that getstats should not include log-probabilities as these will be recalculated by Turing automatically for you.\n\nNotice that both of these functions take the state as input, not the transition. In other words, the transition is completely useless for the external sampler interface. This is in line with long-term plans for removing transitions from AbstractMCMC.jl and only using states.\n\nThere are a few more optional functions which you can implement to improve the integration with Turing.jl:\n\nAbstractMCMC.requires_unconstrained_space(::MySampler): If your sampler requires unconstrained space, you should return true. This tells Turing to perform linking on the VarInfo before evaluation, and ensures that the parameter values passed to your sampler will always be in unconstrained (Euclidean) space.\nTuring.Inference.isgibbscomponent(::MySampler): If you want to disallow your sampler from a component in Turing's Gibbs sampler, you should make this evaluate to false. Note that the default is true, so you should only need to implement this in special cases.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Gibbs","page":"Inference","title":"Turing.Inference.Gibbs","text":"Gibbs\n\nA type representing a Gibbs sampler.\n\nConstructors\n\nGibbs needs to be given a set of pairs of variable names and samplers. Instead of a single variable name per sampler, one can also give an iterable of variables, all of which are sampled by the same component sampler.\n\nEach variable name can be given as either a Symbol or a VarName.\n\nSome examples of valid constructors are:\n\nGibbs(:x => NUTS(), :y => MH())\nGibbs(@varname(x) => NUTS(), @varname(y) => MH())\nGibbs((@varname(x), :y) => NUTS(), :z => MH())\n\nFields\n\nvarnames::NTuple{N, AbstractVector{<:AbstractPPL.VarName}} where N: varnames representing variables for each sampler\nsamplers::NTuple{N, Any} where N: samplers for each entry in varnames\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsConditional","page":"Inference","title":"Turing.Inference.GibbsConditional","text":"GibbsConditional(get_cond_dists)\n\nA Gibbs component sampler that samples variables according to user-provided analytical conditional posterior distributions.\n\nWhen using Gibbs sampling, sometimes one may know the analytical form of the posterior for a given variable, given the conditioned values of the other variables. In such cases one can use GibbsConditional as a component sampler to to sample from these known conditionals directly, avoiding any MCMC methods. One does so with\n\nsampler = Gibbs(\n    (@varname(var1), @varname(var2)) => GibbsConditional(get_cond_dists),\n    other samplers go here...\n)\n\nHere get_cond_dists(c::Dict{<:VarName}) should be a function that takes a Dict mapping the conditioned variables (anything other than var1 and var2) to their values, and returns the conditional posterior distributions for var1 and var2. You may, of course, have any number of variables being sampled as a block in this manner, we only use two as an example. The return value of get_cond_dists should be one of the following:\n\nA single Distribution, if only one variable is being sampled.\nAn AbstractDict{<:VarName,<:Distribution} that maps the variables being sampled to their conditional posteriors E.g. Dict(@varname(var1) => dist1, @varname(var2) => dist2).\nA NamedTuple of Distributions, which is like the AbstractDict case but can be used if all the variable names are single Symbols, and may be more performant. E.g. (; var1=dist1, var2=dist2).\n\nExamples\n\n# Define a model\n@model function inverse_gdemo(x)\n    precision ~ Gamma(2, inv(3))\n    std = sqrt(1 / precision)\n    m ~ Normal(0, std)\n    for i in eachindex(x)\n        x[i] ~ Normal(m, std)\n    end\nend\n\n# Define analytical conditionals. See\n# https://en.wikipedia.org/wiki/Conjugate_prior#When_likelihood_function_is_a_continuous_distribution\nfunction cond_precision(c)\n    a = 2.0\n    b = 3.0\n    # We use AbstractPPL.getvalue instead of indexing into `c` directly to guard against\n    # issues where e.g. you try to get `c[@varname(x[1])]` but only `@varname(x)` is present\n    # in `c`. `getvalue` handles that gracefully, `getindex` doesn't. In this case\n    # `getindex` would suffice, but `getvalue` is good practice.\n    m = AbstractPPL.getvalue(c, @varname(m))\n    x = AbstractPPL.getvalue(c, @varname(x))\n    n = length(x)\n    a_new = a + (n + 1) / 2\n    b_new = b + sum(abs2, x .- m) / 2 + m^2 / 2\n    return Gamma(a_new, 1 / b_new)\nend\n\nfunction cond_m(c)\n    precision = AbstractPPL.getvalue(c, @varname(precision))\n    x = AbstractPPL.getvalue(c, @varname(x))\n    n = length(x)\n    m_mean = sum(x) / (n + 1)\n    m_var = 1 / (precision * (n + 1))\n    return Normal(m_mean, sqrt(m_var))\nend\n\n# Sample using GibbsConditional\nmodel = inverse_gdemo([1.0, 2.0, 3.0])\nchain = sample(model, Gibbs(\n    :precision => GibbsConditional(cond_precision),\n    :m => GibbsConditional(cond_m)\n), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsContext","page":"Inference","title":"Turing.Inference.GibbsContext","text":"GibbsContext(target_varnames, global_varinfo, context)\n\nA context used in the implementation of the Turing.jl Gibbs sampler.\n\nThere will be one GibbsContext for each iteration of a component sampler.\n\ntarget_varnames is a a tuple of VarNames that the current component sampler is sampling. For those VarNames, GibbsContext will just pass tilde_assume!! calls to its child context. For other variables, their values will be fixed to the values they have in global_varinfo.\n\nFields\n\ntarget_varnames: the VarNames being sampled\n\nglobal_varinfo: a Ref to the global AbstractVarInfo object that holds values for all variables, both those fixed and those being sampled. We use a Ref because this field may need to be updated if new variables are introduced.\n\ncontext: the child context that tilde calls will eventually be passed onto.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMC","page":"Inference","title":"Turing.Inference.HMC","text":"HMC(ϵ::Float64, n_leapfrog::Int; adtype::ADTypes.AbstractADType = AutoForwardDiff())\n\nHamiltonian Monte Carlo sampler with static trajectory.\n\nArguments\n\nϵ: The leapfrog step size to use.\nn_leapfrog: The number of leapfrog steps to use.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nUsage\n\nHMC(0.05, 10)\n\nTips\n\nIf you are receiving gradient errors when using HMC, try reducing the leapfrog step size ϵ, e.g.\n\n# Original step size\nsample(gdemo([1.5, 2]), HMC(0.1, 10), 1000)\n\n# Reduced step size\nsample(gdemo([1.5, 2]), HMC(0.01, 10), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMCDA","page":"Inference","title":"Turing.Inference.HMCDA","text":"HMCDA(\n    n_adapts::Int, δ::Float64, λ::Float64; ϵ::Float64 = 0.0;\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nHamiltonian Monte Carlo sampler with Dual Averaging algorithm.\n\nUsage\n\nHMCDA(200, 0.65, 0.3)\n\nArguments\n\nn_adapts: Numbers of samples to use for adaptation.\nδ: Target acceptance rate. 65% is often recommended.\nλ: Target leapfrog length.\nϵ: Initial step size; 0 means automatically search by Turing.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nReference\n\nFor more information, please view the following paper (arXiv link):\n\nHoffman, Matthew D., and Andrew Gelman. \"The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.\" Journal of Machine Learning Research 15, no. 1 (2014): 1593-1623.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.IS","page":"Inference","title":"Turing.Inference.IS","text":"IS()\n\nImportance sampling algorithm.\n\nUsage:\n\nIS()\n\nExample:\n\n# Define a simple Normal model with unknown mean and variance.\n@model function gdemo(x)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0,sqrt.(s))\n    x[1] ~ Normal(m, sqrt.(s))\n    x[2] ~ Normal(m, sqrt.(s))\n    return s², m\nend\n\nsample(gdemo([1.5, 2]), IS(), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.MH","page":"Inference","title":"Turing.Inference.MH","text":"MH([proposal])\n\nConstruct a Metropolis-Hastings algorithm.\n\nThe argument proposal can be\n\nBlank (i.e. MH()), in which case MH defaults to using the prior for each parameter as the proposal distribution.\nA mapping of VarNames to a Distribution, or generic callable that returns a conditional proposal distribution.\nA covariance matrix to use as for mean-zero multivariate normal proposals. Note that if a covariance matrix is passed, sampling occurs in linked space, so the size of an MH step may differ from the size of a step in parameter space.\n\nExamples\n\nConsider the model below:\n\n@model function gdemo()\n    s ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s))\n    1.5 ~ Normal(m, sqrt(s))\n    2.0 ~ Normal(m, sqrt(s))\nend\n\nThe default constructor, MH(), uses the prior distributions as proposals. So, new proposals are obtained by sampling s from InverseGamma(2,3) and m from Normal(0, sqrt(s)).\n\nspl = MH()\n\nAlternatively, a mapping of variable names to proposal distributions can be provided. This implies the use of static proposals for each variable. If a variable is not specified, its prior distribution is used as the proposal.\n\n# Use a static proposal for s² (which happens to be the same\n# as the prior) and a static proposal for m (note that this\n# isn't a random walk proposal).\nspl = MH(\n    # This happens to be the same as the prior\n    @varname(s) => InverseGamma(2, 3),\n    # This is different from the prior\n    @varname(m) => Normal(0, 1),\n)\n\nIf the VarName of interest is a single symbol, you can also use a Symbol instead.\n\nspl = MH(\n    :s => InverseGamma(2, 3),\n    :m => Normal(0, 1),\n)\n\nYou can also use a callable to define a proposal that is conditional on the current values. The callable must accept a single argument, which is a DynamicPPL.VarNamedTuple that holds all the current values of the parameters. You can obtain the value of a specific parameter by indexing into this VarNamedTuple using a VarName (note that symbol indexing is not supported). The callable must then return a Distribution from which to draw the proposal.\n\nnote: Note\nIn general, there is no way for Turing to reliably detect whether a proposal is meant to be a callable or not, since callable structs may have any type. Hence, any proposal that is not a distribution is assumed to be a callable.\n\nspl = MH(\n    # This is a static proposal (same as above).\n    @varname(s) => InverseGamma(2, 3),\n    # This is a conditional proposal, which proposes m from a normal\n    # distribution centred at the current value of m, with a standard\n    # deviation of 0.5.\n    @varname(m) => (vnt -> Normal(vnt[@varname(m)], 0.5)),\n)\n\nProviding a covariance matrix will cause MH to perform random-walk sampling in the transformed space with proposals drawn from a multivariate normal distribution. The provided matrix must be positive semi-definite and square:\n\n# Providing a custom variance-covariance matrix\nspl = MH(\n    [0.25 0.05;\n     0.05 0.50]\n)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.NUTS","page":"Inference","title":"Turing.Inference.NUTS","text":"NUTS(n_adapts::Int, δ::Float64; max_depth::Int=10, Δ_max::Float64=1000.0, init_ϵ::Float64=0.0; adtype::ADTypes.AbstractADType=AutoForwardDiff()\n\nNo-U-Turn Sampler (NUTS) sampler.\n\nUsage:\n\nNUTS()            # Use default NUTS configuration.\nNUTS(1000, 0.65)  # Use 1000 adaption steps, and target accept ratio 0.65.\n\nArguments:\n\nn_adapts::Int : The number of samples to use with adaptation.\nδ::Float64 : Target acceptance rate for dual averaging.\nmax_depth::Int : Maximum doubling tree depth.\nΔ_max::Float64 : Maximum divergence during doubling tree.\ninit_ϵ::Float64 : Initial step size; 0 means automatically searching using a heuristic procedure.\nadtype::ADTypes.AbstractADType : The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG","page":"Inference","title":"Turing.Inference.PG","text":"struct PG{R} <: Turing.Inference.ParticleInference\n\nParticle Gibbs sampler.\n\nFields\n\nnparticles::Int64: Number of particles.\nresampler::Any: Resampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG-Tuple{Int64}","page":"Inference","title":"Turing.Inference.PG","text":"PG(n, [resampler = AdvancedPS.ResampleWithESSThreshold()]) PG(n, [resampler = AdvancedPS.resample_systematic, ]threshold)\n\nCreate a Particle Gibbs sampler of type PG with n particles.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.PolynomialStepsize-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Inference","title":"Turing.Inference.PolynomialStepsize","text":"PolynomialStepsize(a[, b=0, γ=0.55])\n\nCreate a polynomially decaying stepsize function.\n\nAt iteration t, the step size is\n\na (b + t)^-γ\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.Prior","page":"Inference","title":"Turing.Inference.Prior","text":"Prior()\n\nAlgorithm for sampling from the prior.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ProduceLogLikelihoodAccumulator","page":"Inference","title":"Turing.Inference.ProduceLogLikelihoodAccumulator","text":"ProduceLogLikelihoodAccumulator{T<:Real} <: AbstractAccumulator\n\nExactly like LogLikelihoodAccumulator, but calls Libtask.produce on change of value.\n\nFields\n\nlogp::Real: the scalar log likelihood value\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.RepeatSampler","page":"Inference","title":"Turing.Inference.RepeatSampler","text":"RepeatSampler <: AbstractMCMC.AbstractSampler\n\nA RepeatSampler is a container for a sampler and a number of times to repeat it.\n\nFields\n\nsampler: The sampler to repeat\nnum_repeat: The number of times to repeat the sampler\n\nExamples\n\nrepeated_sampler = RepeatSampler(sampler, 10)\nAbstractMCMC.step(rng, model, repeated_sampler) # take 10 steps of `sampler`\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC{AD}\n\nStochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nFields\n\nlearning_rate::Real\nmomentum_decay::Real\nadtype::Any\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC-Tuple{}","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC(;\n    learning_rate::Real,\n    momentum_decay::Real,\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nCreate a Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SGLD","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nFields\n\nstepsize::Any: Step size function.\nadtype::Any\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGLD-Tuple{}","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD(;\n    stepsize = PolynomialStepsize(0.01),\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nBy default, a polynomially decaying stepsize is used.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\nSee also: PolynomialStepsize\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SMC","page":"Inference","title":"Turing.Inference.SMC","text":"struct SMC{R} <: Turing.Inference.ParticleInference\n\nSequential Monte Carlo sampler.\n\nFields\n\nresampler::Any\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SMC-Tuple{}","page":"Inference","title":"Turing.Inference.SMC","text":"SMC([resampler = AdvancedPS.ResampleWithESSThreshold()]) SMC([resampler = AdvancedPS.resample_systematic, ]threshold)\n\nCreate a sequential Monte Carlo sampler of type SMC.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference._convert_initial_params-Tuple{DynamicPPL.AbstractInitStrategy}","page":"Inference","title":"Turing.Inference._convert_initial_params","text":"_convert_initial_params(initial_params)\n\nConvert initial_params to a DynamicPPl.AbstractInitStrategy if it is not already one, or throw a useful error message.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.build_variable_dict-Tuple{DynamicPPL.Model}","page":"Inference","title":"Turing.Inference.build_variable_dict","text":"build_variable_dict(model::DynamicPPL.Model)\n\nTraverse the context stack of model and build a Dict of all the variable values that are set in GibbsContext, ConditionContext, or FixedContext.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.externalsampler-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.externalsampler","text":"externalsampler(\n    sampler::AbstractSampler;\n    adtype=AutoForwardDiff(),\n    unconstrained=AbstractMCMC.requires_unconstrained_space(sampler),\n)\n\nWrap a sampler so it can be used as an inference algorithm.\n\nArguments\n\nsampler::AbstractSampler: The sampler to wrap.\n\nKeyword Arguments\n\nadtype::ADTypes.AbstractADType=ADTypes.AutoForwardDiff(): The automatic differentiation (AD) backend to use.\nunconstrained::Bool=AbstractMCMC.requires_unconstrained_space(sampler): Whether the sampler requires unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.get_trace_local_resampled_maybe-Tuple{Bool}","page":"Inference","title":"Turing.Inference.get_trace_local_resampled_maybe","text":"get_trace_local_resampled_maybe(fallback_resampled::Bool)\n\nGet the Boolean resample value stored in the 'taped globals' of a Libtask.TapedTask, if one exists. If this function is not called within a TapedTask, return the provided fallback_resampled value.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.get_trace_local_rng_maybe-Tuple{Random.AbstractRNG}","page":"Inference","title":"Turing.Inference.get_trace_local_rng_maybe","text":"get_trace_local_rng_maybe(rng::Random.AbstractRNG)\n\nGet the Trace local rng if one exists.\n\nIf executed within a TapedTask, return the rng stored in the \"taped globals\" of the task, otherwise return vi.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.get_trace_local_varinfo_maybe-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.get_trace_local_varinfo_maybe","text":"get_trace_local_varinfo_maybe(vi::AbstractVarInfo)\n\nGet the varinfo stored in the 'taped globals' of a Libtask.TapedTask, if one exists.  If this function is not called within a TapedTask, return the provided varinfo.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_initialstep_recursive","page":"Inference","title":"Turing.Inference.gibbs_initialstep_recursive","text":"Take the first step of MCMC for the first component sampler, and call the same function recursively on the remaining samplers, until no samplers remain. Return the global VarInfo and a tuple of initial states for all component samplers.\n\nThe step_function argument should always be either AbstractMCMC.step or AbstractMCMC.step_warmup.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.gibbs_step_recursive","page":"Inference","title":"Turing.Inference.gibbs_step_recursive","text":"Run a Gibbs step for the first varname/sampler/state tuple, and recursively call the same function on the tail, until there are no more samplers left.\n\nThe step_function argument should always be either AbstractMCMC.step or AbstractMCMC.step_warmup.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.init_strategy-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.init_strategy","text":"Turing.Inference.init_strategy(spl::AbstractSampler)\n\nGet the default initialization strategy for a given sampler spl, i.e. how initial parameters for sampling are chosen if not specified by the user. By default, this is InitFromPrior(), which samples initial parameters from the prior distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.isgibbscomponent-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.isgibbscomponent","text":"isgibbscomponent(spl::AbstractSampler)\n\nReturn a boolean indicating whether spl is a valid component for a Gibbs sampler.\n\nDefaults to true if no method has been defined for a particular sampler.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.loadstate-Tuple{Chains}","page":"Inference","title":"Turing.Inference.loadstate","text":"loadstate(chain::MCMCChains.Chains)\n\nLoad the final state of the sampler from a MCMCChains.Chains object.\n\nTo save the final state of the sampler, you must use sample(...; save_state=true). If this argument was not used during sampling, calling loadstate will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.log_proposal_density-Tuple{DynamicPPL.AbstractVarInfo, InitFromPrior, Dict{AbstractPPL.VarName, Distribution}}","page":"Inference","title":"Turing.Inference.log_proposal_density","text":"log_proposal_density(\n    old_vi::DynamicPPL.AbstractVarInfo,\n    init_strategy_given_new::DynamicPPL.AbstractInitStrategy,\n    unspecified_priors::Dict{VarName,Distribution}\n)\n\nCalculate the ratio g(x|x') where g is the proposal distribution used to generate x (represented by old_vi), given the new state x'.\n\nIf the arguments are switched (i.e., new_vi is passed as the first argument, and init_strategy_given_old as the second), the function calculates g(x'|x).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.make_conditional-Tuple{DynamicPPL.Model, AbstractVector{<:AbstractPPL.VarName}, Any}","page":"Inference","title":"Turing.Inference.make_conditional","text":"make_conditional(model, target_variables, varinfo)\n\nReturn a new, conditioned model for a component of a Gibbs sampler.\n\nArguments\n\nmodel::DynamicPPL.Model: The model to condition.\ntarget_variables::AbstractVector{<:VarName}: The target variables of the component\n\nsampler. These will not be conditioned.\n\nvarinfo::DynamicPPL.AbstractVarInfo: Values for all variables in the model. All the\n\nvalues in varinfo but not in target_variables will be conditioned to the values they have in varinfo.\n\nReturns\n\nA new model with the variables not in target_variables conditioned.\nThe GibbsContext object that will be used to condition the variables. This is necessary\n\nbecause evaluation can mutate its global_varinfo field, which we need to access later.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.match_linking!!-Tuple{Any, Any, Any}","page":"Inference","title":"Turing.Inference.match_linking!!","text":"match_linking!!(varinfo_local, prev_state_local, model)\n\nMake sure the linked/invlinked status of varinfo_local matches that of the previous state for this sampler. This is relevant when multiple samplers are sampling the same variables, and one might need it to be linked while the other doesn't.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.mh_accept-Tuple{Real, Real, Real}","page":"Inference","title":"Turing.Inference.mh_accept","text":"mh_accept(logp_current::Real, logp_proposal::Real, log_proposal_ratio::Real)\n\nDecide if a proposal x with log probability log p(x) = logp_proposal and log proposal ratio log k(x x) - log k(x x) = log_proposal_ratio in a Metropolis-Hastings algorithm with Markov kernel k(x_t x_t+1) and current state x with log probability log p(x) = logp_current is accepted by evaluating the Metropolis-Hastings acceptance criterion\n\nlog U leq log p(x) - log p(x) + log k(x x) - log k(x x)\n\nfor a uniform random number U in 0 1).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_trace_local_varinfo_maybe-Tuple{DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.set_trace_local_varinfo_maybe","text":"set_trace_local_varinfo_maybe(vi::AbstractVarInfo)\n\nSet the Trace local varinfo if executing within a Trace. Return nothing.\n\nIf executed within a TapedTask, set the varinfo stored in the \"taped globals\" of the task. Otherwise do nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.setparams_varinfo!!-Tuple{DynamicPPL.Model, AbstractMCMC.AbstractSampler, Any, DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.setparams_varinfo!!","text":"setparams_varinfo!!(model::DynamicPPL.Model, sampler::AbstractSampler, state, params::AbstractVarInfo)\n\nA lot like AbstractMCMC.setparams!!, but instead of taking a vector of parameters, takes an AbstractVarInfo object. Also takes the sampler as an argument. By default, falls back to AbstractMCMC.setparams!!(model, state, params[:]).\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Module-wide-re-exports","page":"API","title":"Module-wide re-exports","text":"Turing.jl directly re-exports the entire public API of the following packages:\n\nDistributions.jl\nMCMCChains.jl\n\nPlease see the individual packages for their documentation.","category":"section"},{"location":"api/#Individual-exports-and-re-exports","page":"API","title":"Individual exports and re-exports","text":"In this API documentation, for the sake of clarity, we have listed the module that actually defines each of the exported symbols. Note, however, that all of the following symbols are exported unqualified by Turing. That means, for example, you can just write\n\nusing Turing\n\n@model function my_model() end\n\nsample(my_model(), Prior(), 100)\n\ninstead of\n\nDynamicPPL.@model function my_model() end\n\nsample(my_model(), Turing.Inference.Prior(), 100)\n\neven though Prior() is actually defined in the Turing.Inference module and @model in the DynamicPPL package.","category":"section"},{"location":"api/#Modelling","page":"API","title":"Modelling","text":"Exported symbol Documentation Description\n@model DynamicPPL.@model Define a probabilistic model\n@varname AbstractPPL.@varname Generate a VarName from a Julia expression\nto_submodel DynamicPPL.to_submodel Define a submodel\nprefix DynamicPPL.prefix Prefix all variable names in a model with a given VarName\nLogDensityFunction DynamicPPL.LogDensityFunction A struct containing all information about how to evaluate a model. Mostly for advanced users\n@addlogprob! DynamicPPL.@addlogprob! Add arbitrary log-probability terms during model evaluation\nsetthreadsafe DynamicPPL.setthreadsafe Mark a model as requiring threadsafe evaluation","category":"section"},{"location":"api/#Inference","page":"API","title":"Inference","text":"Exported symbol Documentation Description\nsample StatsBase.sample Sample from a model\nMCMCThreads AbstractMCMC.MCMCThreads Run MCMC using multiple threads\nMCMCDistributed AbstractMCMC.MCMCDistributed Run MCMC using multiple processes\nMCMCSerial AbstractMCMC.MCMCSerial Run MCMC using without parallelism\nloadstate Turing.Inference.loadstate Load saved state from MCMCChains.Chains","category":"section"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"Exported symbol Documentation Description\nPrior Turing.Inference.Prior Sample from the prior distribution\nMH Turing.Inference.MH Metropolis–Hastings\nEmcee Turing.Inference.Emcee Affine-invariant ensemble sampler\nESS Turing.Inference.ESS Elliptical slice sampling\nGibbs Turing.Inference.Gibbs Gibbs sampling\nGibbsConditional Turing.Inference.GibbsConditional Gibbs sampling with analytical conditional posterior distributions\nHMC Turing.Inference.HMC Hamiltonian Monte Carlo\nSGLD Turing.Inference.SGLD Stochastic gradient Langevin dynamics\nSGHMC Turing.Inference.SGHMC Stochastic gradient Hamiltonian Monte Carlo\nPolynomialStepsize Turing.Inference.PolynomialStepsize Returns a function which generates polynomially decaying step sizes\nHMCDA Turing.Inference.HMCDA Hamiltonian Monte Carlo with dual averaging\nNUTS Turing.Inference.NUTS No-U-Turn Sampler\nIS Turing.Inference.IS Importance sampling\nSMC Turing.Inference.SMC Sequential Monte Carlo\nPG Turing.Inference.PG Particle Gibbs\nCSMC Turing.Inference.CSMC The same as PG\nRepeatSampler Turing.Inference.RepeatSampler A sampler that runs multiple times on the same variable\nexternalsampler Turing.Inference.externalsampler Wrap an external sampler for use in Turing","category":"section"},{"location":"api/#DynamicPPL-utilities","page":"API","title":"DynamicPPL utilities","text":"Please see the generated quantities and probability interface guides for more information.\n\nExported symbol Documentation Description\nreturned DynamicPPL.returned Calculate additional quantities defined in a model\npredict StatsAPI.predict Generate samples from posterior predictive distribution\npointwise_loglikelihoods DynamicPPL.pointwise_loglikelihoods Compute log likelihoods for each sample in a chain\nlogprior DynamicPPL.logprior Compute log prior probability\nlogjoint DynamicPPL.logjoint Compute log joint probability\ncondition AbstractPPL.condition Condition a model on data\ndecondition AbstractPPL.decondition Remove conditioning on data\nconditioned DynamicPPL.conditioned Return the conditioned values of a model\nfix DynamicPPL.fix Fix the value of a variable\nunfix DynamicPPL.unfix Unfix the value of a variable\nOrderedDict OrderedCollections.OrderedDict An ordered dictionary","category":"section"},{"location":"api/#Initialisation-strategies","page":"API","title":"Initialisation strategies","text":"Turing.jl provides several strategies to initialise parameters for models.\n\nExported symbol Documentation Description\nInitFromPrior DynamicPPL.InitFromPrior Obtain initial parameters from the prior distribution\nInitFromUniform DynamicPPL.InitFromUniform Obtain initial parameters by sampling uniformly in linked space\nInitFromParams DynamicPPL.InitFromParams Manually specify (possibly a subset of) initial parameters","category":"section"},{"location":"api/#Variational-inference","page":"API","title":"Variational inference","text":"See the docs of AdvancedVI.jl for detailed usage and the variational inference tutorial for a basic walkthrough.\n\nExported symbol Documentation Description\nvi Turing.vi Perform variational inference\nq_locationscale Turing.Variational.q_locationscale Find a numerically non-degenerate initialization for a location-scale variational family\nq_meanfield_gaussian Turing.Variational.q_meanfield_gaussian Find a numerically non-degenerate initialization for a mean-field Gaussian family\nq_fullrank_gaussian Turing.Variational.q_fullrank_gaussian Find a numerically non-degenerate initialization for a full-rank Gaussian family\nKLMinRepGradDescent Turing.Variational.KLMinRepGradDescent KL divergence minimization via stochastic gradient descent with the reparameterization gradient\nKLMinRepGradProxDescent Turing.Variational.KLMinRepGradProxDescent KL divergence minimization via stochastic proximal gradient descent with the reparameterization gradient over location-scale variational families\nKLMinScoreGradDescent Turing.Variational.KLMinScoreGradDescent KL divergence minimization via stochastic gradient descent with the score gradient\nKLMinWassFwdBwd Turing.Variational.KLMinWassFwdBwd KL divergence minimization via Wasserstein proximal gradient descent\nKLMinNaturalGradDescent Turing.Variational.KLMinNaturalGradDescent KL divergence minimization via natural gradient descent\nKLMinSqrtNaturalGradDescent Turing.Variational.KLMinSqrtNaturalGradDescent KL divergence minimization via natural gradient descent in the square-root parameterization\nFisherMinBatchMatch Turing.Variational.FisherMinBatchMatch Covariance-weighted Fisher divergence minimization via the batch-and-match algorithm","category":"section"},{"location":"api/#Automatic-differentiation-types","page":"API","title":"Automatic differentiation types","text":"These are used to specify the automatic differentiation backend to use. See the AD guide for more information.\n\nExported symbol Documentation Description\nAutoEnzyme ADTypes.AutoEnzyme Enzyme.jl backend\nAutoForwardDiff ADTypes.AutoForwardDiff ForwardDiff.jl backend\nAutoMooncake ADTypes.AutoMooncake Mooncake.jl backend\nAutoReverseDiff ADTypes.AutoReverseDiff ReverseDiff.jl backend","category":"section"},{"location":"api/#Debugging","page":"API","title":"Debugging","text":"","category":"section"},{"location":"api/#Distributions","page":"API","title":"Distributions","text":"These distributions are defined in Turing.jl, but not in Distributions.jl.","category":"section"},{"location":"api/#Tools-to-work-with-distributions","page":"API","title":"Tools to work with distributions","text":"Exported symbol Documentation Description\nI LinearAlgebra.I Identity matrix\nfilldist DistributionsAD.filldist Create a product distribution from a distribution and integers\narraydist DistributionsAD.arraydist Create a product distribution from an array of distributions\nNamedDist DynamicPPL.NamedDist A distribution that carries the name of the variable","category":"section"},{"location":"api/#Point-estimates","page":"API","title":"Point estimates","text":"See the mode estimation tutorial for more information.\n\nExported symbol Documentation Description\nmaximum_a_posteriori Turing.Optimisation.maximum_a_posteriori Find a MAP estimate for a model\nmaximum_likelihood Turing.Optimisation.maximum_likelihood Find a MLE estimate for a model\nMAP Turing.Optimisation.MAP Type to use with Optim.jl for MAP estimation\nMLE Turing.Optimisation.MLE Type to use with Optim.jl for MLE estimation","category":"section"},{"location":"api/#Turing.setprogress!","page":"API","title":"Turing.setprogress!","text":"setprogress!(progress::Bool)\n\nEnable progress logging in Turing if progress is true, and disable it otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Turing.Flat","page":"API","title":"Turing.Flat","text":"Flat()\n\nThe flat distribution is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = 1\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.FlatPos","page":"API","title":"Turing.FlatPos","text":"FlatPos(l::Real)\n\nThe positive flat distribution with real-valued parameter l is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = begincases\n0  textif  x leq l \n1  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.BinomialLogit","page":"API","title":"Turing.BinomialLogit","text":"BinomialLogit(n, logitp)\n\nThe Binomial distribution with logit parameterization characterizes the number of successes in a sequence of independent trials.\n\nIt has two parameters: n, the number of trials, and logitp, the logit of the probability of success in an individual trial, with the distribution\n\nP(X = k) = n choose k(textlogistic(logitp))^k (1 - textlogistic(logitp))^n-k quad text for  k = 012 ldots n\n\nSee also: Distributions.Binomial\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.OrderedLogistic","page":"API","title":"Turing.OrderedLogistic","text":"OrderedLogistic(η, c::AbstractVector)\n\nThe ordered logistic distribution with real-valued parameter η and cutpoints c has the probability mass function\n\nP(X = k) = begincases\n    1 - textlogistic(eta - c_1)  textif  k = 1 \n    textlogistic(eta - c_k-1) - textlogistic(eta - c_k)  textif  1  k  K \n    textlogistic(eta - c_K-1)  textif  k = K\nendcases\n\nwhere K = length(c) + 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.LogPoisson","page":"API","title":"Turing.LogPoisson","text":"LogPoisson(logλ)\n\nThe Poisson distribution with logarithmic parameterization of the rate parameter describes the number of independent events occurring within a unit time interval, given the average rate of occurrence exp(loglambda).\n\nThe distribution has the probability mass function\n\nP(X = k) = frace^k cdot loglambdak e^-e^loglambda quad text for  k = 012ldots\n\nSee also: Distributions.Poisson\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#API:-Turing.RandomMeasures","page":"RandomMeasures ","title":"API: Turing.RandomMeasures","text":"","category":"section"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.ChineseRestaurantProcess","page":"RandomMeasures ","title":"Turing.RandomMeasures.ChineseRestaurantProcess","text":"ChineseRestaurantProcess(rpm, m)\n\nThe Chinese Restaurant Process for random probability measures rpm with counts m.\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.DirichletProcess","page":"RandomMeasures ","title":"Turing.RandomMeasures.DirichletProcess","text":"DirichletProcess(α)\n\nThe Dirichlet Process with concentration parameter α. Samples from the Dirichlet process can be constructed via the following representations.\n\nSize-Biased Sampling Process\n\nj_k sim Beta(1 alpha) * surplus\n\nStick-Breaking Process\n\nv_k sim Beta(1 alpha)\n\nChinese Restaurant Process\n\np(z_n = k  z_1n-1) propto begincases\n        fracm_kn-1+alpha textif m_k  0\n        fracalphan-1+alpha\n    endcases\n\nFor more details see: https://www.stats.ox.ac.uk/~teh/research/npbayes/Teh2010a.pdf\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.PitmanYorProcess","page":"RandomMeasures ","title":"Turing.RandomMeasures.PitmanYorProcess","text":"PitmanYorProcess(d, θ, t)\n\nThe Pitman-Yor Process with discount d, concentration θ and t already drawn atoms. Samples from the Pitman-Yor Process can be constructed via the following representations.\n\nSize-Biased Sampling Process\n\nj_k sim Beta(1-d theta + t*d) * surplus\n\nStick-Breaking Process\n\nv_k sim Beta(1-d theta + t*d)\n\nChinese Restaurant Process\n\np(z_n = k  z_1n-1) propto begincases\n        fracm_k - dn+theta textif m_k  0\n        fractheta + d*tn+theta\n    endcases\n\nFor more details see: https://en.wikipedia.org/wiki/Pitman–Yor_process\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.SizeBiasedSamplingProcess","page":"RandomMeasures ","title":"Turing.RandomMeasures.SizeBiasedSamplingProcess","text":"SizeBiasedSamplingProcess(rpm, surplus)\n\nThe Size-Biased Sampling Process for random probability measures rpm with a surplus mass of surplus.\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.StickBreakingProcess","page":"RandomMeasures ","title":"Turing.RandomMeasures.StickBreakingProcess","text":"StickBreakingProcess(rpm)\n\nThe Stick-Breaking Process for random probability measures rpm.\n\n\n\n\n\n","category":"type"},{"location":"api/RandomMeasures/#Turing.RandomMeasures._logpdf_table","page":"RandomMeasures ","title":"Turing.RandomMeasures._logpdf_table","text":"_logpdf_table(d::AbstractRandomProbabilityMeasure, m::AbstractVector{Int})\n\nParameters:\n\nd: Random probability measure, e.g. DirichletProcess\nm: Cluster counts\n\n\n\n\n\n","category":"function"},{"location":"api/RandomMeasures/#Turing.RandomMeasures.stickbreak-Tuple{Any}","page":"RandomMeasures ","title":"Turing.RandomMeasures.stickbreak","text":"Stick-breaking function.\n\nThis function accepts a vector (`v`) of length $K - 1$ where each element\nis assumed to be in the unit interval, and returns a simplex of length\n$K$.  If the supplied vector `v` is a vector of independent draws from\na Beta distribution (i.e., vⱼ | a ~ Beta(1, a), for j=1,...,K), then\nreturned simplex is generated via a stick-breaking process where\nthe first element of the stick is w₁ = v₁, the last element w_K =\n∏ⱼ (1 - vⱼ), and the other elements are wₖ = vₖ ∏ⱼ₌₁ᵏ⁻¹(1 - vⱼ).\nAs $K$ goes to infinity, w is a draw from the Chinese Restaurant process\nwith mass parameter a.\n\nArguments\n\nv: A vector of length K - 1, where K  1.\n\nReturn\n\nA simplex (w) of dimension K. Where ∑ₖ wₖ = 1, and each wₖ ≥ 0.\n\n\n\n\n\n","category":"method"},{"location":"#Turing.jl","page":"Home","title":"Turing.jl","text":"This site contains the API documentation for the identifiers exported by Turing.jl.\n\nIf you are looking for usage examples and guides, please visit https://turinglang.org/docs.","category":"section"},{"location":"api/Variational/#API:-Turing.Variational","page":"Variational ","title":"API: Turing.Variational","text":"","category":"section"},{"location":"api/Variational/#Turing.Variational.q_fullrank_gaussian-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_fullrank_gaussian","text":"q_fullrank_gaussian(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:LowerTriangular} = nothing,\n    kwargs...\n)\n\nFind a numerically non-degenerate Gaussian q with a scale with full-rank factors (traditionally referred to as a \"full-rank family\") for approximating the target model.\n\nIf the scale set as nothing, the default value will be a zero-mean Gaussian with a LowerTriangular scale matrix (resulting in a covariance with \"full-rank\" factors) no larger than 0.6*I (covariance of 0.6^2*I). This guarantees that the samples from the initial variational approximation will fall in the range of (-2, 2) with 99.9% probability, which mimics the behavior of the Turing.InitFromUniform() strategy. Whether the default choice is used or not, the scale may be adjusted via q_initialize_scale so that the log-densities of model are finite over the samples from q.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\n\nThe remaining keyword arguments are passed to q_locationscale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_initialize_scale-Tuple{Random.AbstractRNG, DynamicPPL.Model, AbstractVector, AbstractMatrix, UnivariateDistribution}","page":"Variational ","title":"Turing.Variational.q_initialize_scale","text":"q_initialize_scale(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model,\n    location::AbstractVector,\n    scale::AbstractMatrix,\n    basedist::Distributions.UnivariateDistribution;\n    num_samples::Int = 10,\n    num_max_trials::Int = 10,\n    reduce_factor::Real = one(eltype(scale)) / 2\n)\n\nGiven an initial location-scale distribution q formed by location, scale, and basedist, shrink scale until the expectation of log-densities of model taken over q are finite. If the log-densities are not finite even after num_max_trials, throw an error.\n\nFor reference, a location-scale distribution q formed by location, scale, and basedist is a distribution where its sampling process z sim q can be represented as\n\nu = rand(basedist, d)\nz = scale * u + location\n\nArguments\n\nmodel: The target DynamicPPL.Model.\nlocation: The location parameter of the initialization.\nscale: The scale parameter of the initialization.\nbasedist: The base distribution of the location-scale family.\n\nKeyword Arguments\n\nnum_samples: Number of samples used to compute the average log-density at each trial.\nnum_max_trials: Number of trials until throwing an error.\nreduce_factor: Factor for shrinking the scale. After n trials, the scale is then scale*reduce_factor^n.\n\nReturns\n\nscale_adj: The adjusted scale matrix matching the type of scale.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_locationscale-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_locationscale","text":"q_locationscale(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:Diagonal,<:LowerTriangular} = nothing,\n    meanfield::Bool = true,\n    basedist::Distributions.UnivariateDistribution = Normal()\n)\n\nFind a numerically non-degenerate variational distribution q for approximating the  target model within the location-scale variational family formed by the type of scale and basedist.\n\nThe distribution can be manually specified by setting location, scale, and basedist. Otherwise, it chooses a Gaussian with zero-mean and scale 0.6*I (covariance of 0.6^2*I) by default. This guarantees that the samples from the initial variational approximation will fall in the range of (-2, 2) with 99.9% probability, which mimics the behavior of the Turing.InitFromUniform() strategy.\n\nWhether the default choice is used or not, the scale may be adjusted via q_initialize_scale so that the log-densities of model are finite over the samples from q. If meanfield is set as true, the scale of q is restricted to be a diagonal matrix and only the diagonal of scale is used.\n\nFor reference, a location-scale distribution q formed by location, scale, and basedist is a distribution where its sampling process z sim q can be represented as\n\nu = rand(basedist, d)\nz = scale * u + location\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\nmeanfield: Whether to use the mean-field approximation. If true, scale is converted into a Diagonal matrix. Otherwise, it is converted into a LowerTriangular matrix.\nbasedist: The base distribution of the location-scale family.\n\nThe remaining keywords are passed to q_initialize_scale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.q_meanfield_gaussian-Tuple{Random.AbstractRNG, DynamicPPL.Model}","page":"Variational ","title":"Turing.Variational.q_meanfield_gaussian","text":"q_meanfield_gaussian(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model;\n    location::Union{Nothing,<:AbstractVector} = nothing,\n    scale::Union{Nothing,<:Diagonal} = nothing,\n    kwargs...\n)\n\nFind a numerically non-degenerate mean-field Gaussian q for approximating the  target model.\n\nIf the scale set as nothing, the default value will be a zero-mean Gaussian with a Diagonal scale matrix (the \"mean-field\" approximation) no larger than 0.6*I (covariance of 0.6^2*I). This guarantees that the samples from the initial variational approximation will fall in the range of (-2, 2) with 99.9% probability, which mimics the behavior of the Turing.InitFromUniform() strategy. Whether the default choice is used or not, the scale may be adjusted via q_initialize_scale so that the log-densities of model are finite over the samples from q.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\n\nKeyword Arguments\n\nlocation: The location parameter of the initialization. If nothing, a vector of zeros is used.\nscale: The scale parameter of the initialization. If nothing, an identity matrix is used.\n\nThe remaining keyword arguments are passed to q_locationscale.\n\nReturns\n\nq::Bijectors.TransformedDistribution: A AdvancedVI.LocationScale distribution matching the support of model.\n\n\n\n\n\n","category":"method"},{"location":"api/Variational/#Turing.Variational.vi-Tuple{Random.AbstractRNG, DynamicPPL.Model, Any, Int64, Vararg{Any}}","page":"Variational ","title":"Turing.Variational.vi","text":"vi(\n    [rng::Random.AbstractRNG,]\n    model::DynamicPPL.Model,\n    q,\n    max_iter::Int;\n    adtype::ADTypes.AbstractADType=DEFAULT_ADTYPE,\n    algorithm::AdvancedVI.AbstractVariationalAlgorithm = KLMinRepGradProxDescent(\n        adtype; n_samples=10\n    ),\n    show_progress::Bool = Turing.PROGRESS[],\n    kwargs...\n)\n\nApproximate the target model via the variational inference algorithm algorithm by starting from the initial variational approximation q. This is a thin wrapper around AdvancedVI.optimize.\n\nIf the chosen variational inference algorithm operates in an unconstrained space, then the provided initial variational approximation q must be a Bijectors.TransformedDistribution of an unconstrained distribution. For example, the initialization supplied by  q_meanfield_gaussian,q_fullrank_gaussian, q_locationscale.\n\nThe default algorithm, KLMinRepGradProxDescent (relevant docs), assumes q uses AdvancedVI.MvLocationScale, which can be constructed by invoking q_fullrank_gaussian or q_meanfield_gaussian. For other variational families, refer to the documentation of AdvancedVI to determine the best algorithm and other options.\n\nArguments\n\nmodel: The target DynamicPPL.Model.\nq: The initial variational approximation.\nmax_iter: Maximum number of steps.\nAny additional arguments are passed on to AdvancedVI.optimize.\n\nKeyword Arguments\n\nadtype: Automatic differentiation backend to be applied to the log-density. The default value for algorithm also uses this backend for differentiating the variational objective.\nalgorithm: Variational inference algorithm. The default is KLMinRepGradProxDescent, please refer to AdvancedVI docs for all the options.\nshow_progress: Whether to show the progress bar.\nunconstrained: Whether to transform the posterior to be unconstrained for running the variational inference algorithm. If true, then the output q will be wrapped into a Bijectors.TransformedDistribution with the transformation matching the support of the posterior. The default value depends on the chosen algorithm.\nAny additional keyword arguments are passed on to AdvancedVI.optimize.\n\nSee the docs of AdvancedVI.optimize for additional keyword arguments.\n\nReturns\n\nq: Output variational distribution of algorithm.\nstate: Collection of states used by algorithm. This can be used to resume from a past call to vi.\ninfo: Information generated while executing algorithm.\n\n\n\n\n\n","category":"method"}]
}
