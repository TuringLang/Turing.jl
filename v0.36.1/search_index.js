var documenterSearchIndex = {"docs":
[{"location":"api/Optimisation/#API:-Turing.Optimisation","page":"Optimisation","title":"API: Turing.Optimisation","text":"","category":"section"},{"location":"api/Optimisation/","page":"Optimisation","title":"Optimisation","text":"Modules = [Turing.Optimisation]\nOrder  = [:type, :function]","category":"page"},{"location":"api/Optimisation/#SciMLBase.OptimizationProblem-Tuple{LogDensityFunction{V, M, C} where {M<:DynamicPPL.Model, C<:Turing.Optimisation.OptimizationContext, V<:DynamicPPL.VarInfo}, Any, Any}","page":"Optimisation","title":"SciMLBase.OptimizationProblem","text":"OptimizationProblem(log_density::OptimLogDensity, adtype, constraints)\n\nCreate an OptimizationProblem for the objective function defined by log_density.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.MAP","page":"Optimisation","title":"Turing.Optimisation.MAP","text":"MAP <: ModeEstimator\n\nConcrete type for maximum a posteriori estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.MLE","page":"Optimisation","title":"Turing.Optimisation.MLE","text":"MLE <: ModeEstimator\n\nConcrete type for maximum likelihood estimation. Only used for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimationConstraints","page":"Optimisation","title":"Turing.Optimisation.ModeEstimationConstraints","text":"ModeEstimationConstraints\n\nA struct that holds constraints for mode estimation problems.\n\nThe fields are the same as possible constraints supported by the Optimization.jl: ub and lb specify lower and upper bounds of box constraints. cons is a function that takes the parameters of the model and returns a list of derived quantities, which are then constrained by the lower and upper bounds set by lcons and ucons. We refer to these as generic constraints. Please see the documentation of Optimization.jl for more details.\n\nAny of the fields can be nothing, disabling the corresponding constraints.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeEstimator","page":"Optimisation","title":"Turing.Optimisation.ModeEstimator","text":"ModeEstimator\n\nAn abstract type to mark whether mode estimation is to be done with maximum a posteriori (MAP) or maximum likelihood estimation (MLE). This is only needed for the Optim.jl interface.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult{\n    V<:NamedArrays.NamedArray,\n    M<:NamedArrays.NamedArray,\n    O<:Optim.MultivariateOptimizationResults,\n    S<:NamedArrays.NamedArray\n}\n\nA wrapper struct to store various results from a MAP or MLE estimation.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.ModeResult-Tuple{LogDensityFunction{V, M, C} where {M<:DynamicPPL.Model, C<:Turing.Optimisation.OptimizationContext, V<:DynamicPPL.VarInfo}, SciMLBase.OptimizationSolution}","page":"Optimisation","title":"Turing.Optimisation.ModeResult","text":"ModeResult(log_density::OptimLogDensity, solution::SciMLBase.OptimizationSolution)\n\nCreate a ModeResult for a given log_density objective and a solution given by solve.\n\nOptimization.solve returns its own result type. This function converts that into the richer format of ModeResult. It also takes care of transforming them back to the original parameter space in case the optimization was done in a transformed space.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity{M<:DynamicPPL.Model,C<:Context,V<:DynamicPPL.VarInfo}\n\nA struct that stores the negative log density function of a DynamicPPL model.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{AbstractVector}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"(f::OptimLogDensity)(z)\n(f::OptimLogDensity)(z, _)\n\nEvaluate the negative log joint or log likelihood at the array z. Which one is evaluated depends on the context of f.\n\nAny second argument is ignored. The two-argument method only exists to match interface the required by Optimization.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimLogDensity-Tuple{DynamicPPL.Model, Turing.Optimisation.OptimizationContext}","page":"Optimisation","title":"Turing.Optimisation.OptimLogDensity","text":"OptimLogDensity(model::DynamicPPL.Model, context::OptimizationContext)\n\nCreate a callable OptimLogDensity struct that evaluates a model using the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.OptimizationContext","page":"Optimisation","title":"Turing.Optimisation.OptimizationContext","text":"OptimizationContext{C<:AbstractContext} <: AbstractContext\n\nThe OptimizationContext transforms variables to their constrained space, but does not use the density with respect to the transformation. This context is intended to allow an optimizer to sample in R^n freely.\n\n\n\n\n\n","category":"type"},{"location":"api/Optimisation/#Base.get-Tuple{Turing.Optimisation.ModeResult, AbstractVector{Symbol}}","page":"Optimisation","title":"Base.get","text":"Base.get(m::ModeResult, var_symbol::Symbol)\nBase.get(m::ModeResult, var_symbols::AbstractVector{Symbol})\n\nReturn the values of all the variables with the symbol(s) var_symbol in the mode result m. The return value is a NamedTuple with var_symbols as the key(s). The second argument should be either a Symbol or a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.estimate_mode","page":"Optimisation","title":"Turing.Optimisation.estimate_mode","text":"estimate_mode(\n    model::DynamicPPL.Model,\n    estimator::ModeEstimator,\n    [solver];\n    kwargs...\n)\n\nFind the mode of the probability distribution of a model.\n\nUnder the hood this function calls Optimization.solve.\n\nArguments\n\nmodel::DynamicPPL.Model: The model for which to estimate the mode.\nestimator::ModeEstimator: Can be either MLE() for maximum likelihood estimation or   MAP() for maximum a posteriori estimation.\nsolver=nothing. The optimization algorithm to use. Optional. Can be any solver   recognised by Optimization.jl. If omitted a default solver is used: LBFGS, or IPNewton   if non-box constraints are present.\n\nKeyword arguments\n\ninitial_params::Union{AbstractVector,Nothing}=nothing: Initial value for the   optimization. Optional, unless non-box constraints are specified. If omitted it is   generated by either sampling from the prior distribution or uniformly from the box   constraints, if any.\nadtype::AbstractADType=AutoForwardDiff(): The automatic differentiation type to use.\nKeyword arguments lb, ub, cons, lcons, and ucons define constraints for the   optimization problem. Please see ModeEstimationConstraints for more details.\nAny extra keyword arguments are passed to Optimization.solve.\n\n\n\n\n\n","category":"function"},{"location":"api/Optimisation/#Turing.Optimisation.generate_initial_params-Tuple{DynamicPPL.Model, Any, Any}","page":"Optimisation","title":"Turing.Optimisation.generate_initial_params","text":"generate_initial_params(model::DynamicPPL.Model, initial_params, constraints)\n\nGenerate an initial value for the optimization problem.\n\nIf initial_params is not nothing, a copy of it is returned. Otherwise initial parameter values are generated either by sampling from the prior (if no constraints are present) or uniformly from the box constraints. If generic constraints are set, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_a_posteriori-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_a_posteriori","text":"maximum_a_posteriori(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum a posteriori estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MAP() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Optimisation/#Turing.Optimisation.maximum_likelihood-Tuple{DynamicPPL.Model, Vararg{Any}}","page":"Optimisation","title":"Turing.Optimisation.maximum_likelihood","text":"maximum_likelihood(\n    model::DynamicPPL.Model,\n    [solver];\n    kwargs...\n)\n\nFind the maximum likelihood estimate of a model.\n\nThis is a convenience function that calls estimate_mode with MLE() as the estimator. Please see the documentation of Turing.Optimisation.estimate_mode for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#API:-Turing.Inference","page":"Inference","title":"API: Turing.Inference","text":"","category":"section"},{"location":"api/Inference/","page":"Inference","title":"Inference","text":"Modules = [Turing.Inference]\nOrder  = [:type, :function]","category":"page"},{"location":"api/Inference/#Turing.Inference.CSMC","page":"Inference","title":"Turing.Inference.CSMC","text":"CSMC(...)\n\nEquivalent to PG.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ESS","page":"Inference","title":"Turing.Inference.ESS","text":"ESS\n\nElliptical slice sampling algorithm.\n\nExamples\n\njulia> @model function gdemo(x)\n           m ~ Normal()\n           x ~ Normal(m, 0.5)\n       end\ngdemo (generic function with 2 methods)\n\njulia> sample(gdemo(1.0), ESS(), 1_000) |> mean\nMean\n\n│ Row │ parameters │ mean     │\n│     │ Symbol     │ Float64  │\n├─────┼────────────┼──────────┤\n│ 1   │ m          │ 0.824853 │\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Emcee","page":"Inference","title":"Turing.Inference.Emcee","text":"Emcee(n_walkers::Int, stretch_length=2.0)\n\nAffine-invariant ensemble sampling algorithm.\n\nReference\n\nForeman-Mackey, D., Hogg, D. W., Lang, D., & Goodman, J. (2013). emcee: The MCMC Hammer. Publications of the Astronomical Society of the Pacific, 125 (925), 306. https://doi.org/10.1086/670067\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.ExternalSampler","page":"Inference","title":"Turing.Inference.ExternalSampler","text":"ExternalSampler{S<:AbstractSampler,AD<:ADTypes.AbstractADType,Unconstrained}\n\nRepresents a sampler that is not an implementation of InferenceAlgorithm.\n\nThe Unconstrained type-parameter is to indicate whether the sampler requires unconstrained space.\n\nFields\n\nsampler::AbstractMCMC.AbstractSampler: the sampler to wrap\nadtype::ADTypes.AbstractADType: the automatic differentiation (AD) backend to use\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.Gibbs","page":"Inference","title":"Turing.Inference.Gibbs","text":"Gibbs\n\nA type representing a Gibbs sampler.\n\nConstructors\n\nGibbs needs to be given a set of pairs of variable names and samplers. Instead of a single variable name per sampler, one can also give an iterable of variables, all of which are sampled by the same component sampler.\n\nEach variable name can be given as either a Symbol or a VarName.\n\nSome examples of valid constructors are:\n\nGibbs(:x => NUTS(), :y => MH())\nGibbs(@varname(x) => NUTS(), @varname(y) => MH())\nGibbs((@varname(x), :y) => NUTS(), :z => MH())\n\nCurrently only variable names without indexing are supported, so for instance Gibbs(@varname(x[1]) => NUTS()) does not work. This will hopefully change in the future.\n\nFields\n\nvarnames::NTuple{N, AbstractVector{<:AbstractPPL.VarName}} where N: varnames representing variables for each sampler\nsamplers::NTuple{N, Any} where N: samplers for each entry in varnames\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.GibbsContext","page":"Inference","title":"Turing.Inference.GibbsContext","text":"GibbsContext{VNs}(global_varinfo, context)\n\nA context used in the implementation of the Turing.jl Gibbs sampler.\n\nThere will be one GibbsContext for each iteration of a component sampler.\n\nVNs is a a tuple of symbols for VarNames that the current component sampler is sampling. For those VarNames, GibbsContext will just pass tilde_assume calls to its child context. For other variables, their values will be fixed to the values they have in global_varinfo.\n\nThe naive implementation of GibbsContext would simply have a field target_varnames that would be a collection of VarNames that the current component sampler is sampling. The reason we instead have a Tuple type parameter listing Symbols is to allow is_target_varname to benefit from compile time constant propagation. This is important for type stability of tilde_assume.\n\nFields\n\nglobal_varinfo: a Ref to the global AbstractVarInfo object that holds values for all variables, both those fixed and those being sampled. We use a Ref because this field may need to be updated if new variables are introduced.\n\ncontext: the child context that tilde calls will eventually be passed onto.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMC","page":"Inference","title":"Turing.Inference.HMC","text":"HMC(ϵ::Float64, n_leapfrog::Int; adtype::ADTypes.AbstractADType = AutoForwardDiff())\n\nHamiltonian Monte Carlo sampler with static trajectory.\n\nArguments\n\nϵ: The leapfrog step size to use.\nn_leapfrog: The number of leapfrog steps to use.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nUsage\n\nHMC(0.05, 10)\n\nTips\n\nIf you are receiving gradient errors when using HMC, try reducing the leapfrog step size ϵ, e.g.\n\n# Original step size\nsample(gdemo([1.5, 2]), HMC(0.1, 10), 1000)\n\n# Reduced step size\nsample(gdemo([1.5, 2]), HMC(0.01, 10), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.HMCDA","page":"Inference","title":"Turing.Inference.HMCDA","text":"HMCDA(\n    n_adapts::Int, δ::Float64, λ::Float64; ϵ::Float64 = 0.0;\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nHamiltonian Monte Carlo sampler with Dual Averaging algorithm.\n\nUsage\n\nHMCDA(200, 0.65, 0.3)\n\nArguments\n\nn_adapts: Numbers of samples to use for adaptation.\nδ: Target acceptance rate. 65% is often recommended.\nλ: Target leapfrog length.\nϵ: Initial step size; 0 means automatically search by Turing.\nadtype: The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\nReference\n\nFor more information, please view the following paper (arXiv link):\n\nHoffman, Matthew D., and Andrew Gelman. \"The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.\" Journal of Machine Learning Research 15, no. 1 (2014): 1593-1623.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.IS","page":"Inference","title":"Turing.Inference.IS","text":"IS()\n\nImportance sampling algorithm.\n\nUsage:\n\nIS()\n\nExample:\n\n# Define a simple Normal model with unknown mean and variance.\n@model function gdemo(x)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0,sqrt.(s))\n    x[1] ~ Normal(m, sqrt.(s))\n    x[2] ~ Normal(m, sqrt.(s))\n    return s², m\nend\n\nsample(gdemo([1.5, 2]), IS(), 1000)\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.MH-Tuple","page":"Inference","title":"Turing.Inference.MH","text":"MH(space...)\n\nConstruct a Metropolis-Hastings algorithm.\n\nThe arguments space can be\n\nBlank (i.e. MH()), in which case MH defaults to using the prior for each parameter as the proposal distribution.\nAn iterable of pairs or tuples mapping a Symbol to a AdvancedMH.Proposal, Distribution, or Function that generates returns a conditional proposal distribution.\nA covariance matrix to use as for mean-zero multivariate normal proposals.\n\nExamples\n\nThe default MH will draw proposal samples from the prior distribution using AdvancedMH.StaticProposal.\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2,3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend\n\nchain = sample(gdemo(1.5, 2.0), MH(), 1_000)\nmean(chain)\n\nSpecifying a single distribution implies the use of static MH:\n\n# Use a static proposal for s² (which happens to be the same\n# as the prior) and a static proposal for m (note that this\n# isn't a random walk proposal).\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => InverseGamma(2, 3),\n        :m => Normal(0, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nSpecifying explicit proposals using the AdvancedMH interface:\n\n# Use a static proposal for s² and random walk with proposal\n# standard deviation of 0.25 for m.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => AdvancedMH.StaticProposal(InverseGamma(2,3)),\n        :m => AdvancedMH.RandomWalkProposal(Normal(0, 0.25))\n    ),\n    1_000\n)\nmean(chain)\n\nUsing a custom function to specify a conditional distribution:\n\n# Use a static proposal for s and and a conditional proposal for m,\n# where the proposal is centered around the current sample.\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        :s² => InverseGamma(2, 3),\n        :m => x -> Normal(x, 1)\n    ),\n    1_000\n)\nmean(chain)\n\nProviding a covariance matrix will cause MH to perform random-walk sampling in the transformed space with proposals drawn from a multivariate normal distribution. The provided matrix must be positive semi-definite and square:\n\n# Providing a custom variance-covariance matrix\nchain = sample(\n    gdemo(1.5, 2.0),\n    MH(\n        [0.25 0.05;\n         0.05 0.50]\n    ),\n    1_000\n)\nmean(chain)\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.MHLogDensityFunction","page":"Inference","title":"Turing.Inference.MHLogDensityFunction","text":"MHLogDensityFunction\n\nA log density function for the MH sampler.\n\nThis variant uses the  set_namedtuple! function to update the VarInfo.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.NUTS","page":"Inference","title":"Turing.Inference.NUTS","text":"NUTS(n_adapts::Int, δ::Float64; max_depth::Int=10, Δ_max::Float64=1000.0, init_ϵ::Float64=0.0; adtype::ADTypes.AbstractADType=AutoForwardDiff()\n\nNo-U-Turn Sampler (NUTS) sampler.\n\nUsage:\n\nNUTS()            # Use default NUTS configuration.\nNUTS(1000, 0.65)  # Use 1000 adaption steps, and target accept ratio 0.65.\n\nArguments:\n\nn_adapts::Int : The number of samples to use with adaptation.\nδ::Float64 : Target acceptance rate for dual averaging.\nmax_depth::Int : Maximum doubling tree depth.\nΔ_max::Float64 : Maximum divergence during doubling tree.\ninit_ϵ::Float64 : Initial step size; 0 means automatically searching using a heuristic procedure.\nadtype::ADTypes.AbstractADType : The automatic differentiation (AD) backend.   If not specified, ForwardDiff is used, with its chunksize automatically determined.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG","page":"Inference","title":"Turing.Inference.PG","text":"PG(n, space...)\nPG(n, [resampler = AdvancedPS.ResampleWithESSThreshold(), space = ()])\nPG(n, [resampler = AdvancedPS.resample_systematic, ]threshold[, space = ()])\n\nCreate a Particle Gibbs sampler of type PG with n particles for the variables in space.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PG-2","page":"Inference","title":"Turing.Inference.PG","text":"struct PG{space, R} <: Turing.Inference.ParticleInference\n\nParticle Gibbs sampler.\n\nFields\n\nnparticles::Int64: Number of particles.\nresampler::Any: Resampling algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.PolynomialStepsize-Union{Tuple{T}, Tuple{T, T, T}} where T<:Real","page":"Inference","title":"Turing.Inference.PolynomialStepsize","text":"PolynomialStepsize(a[, b=0, γ=0.55])\n\nCreate a polynomially decaying stepsize function.\n\nAt iteration t, the step size is\n\na (b + t)^-γ\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.Prior","page":"Inference","title":"Turing.Inference.Prior","text":"Prior()\n\nAlgorithm for sampling from the prior.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.RepeatSampler","page":"Inference","title":"Turing.Inference.RepeatSampler","text":"RepeatSampler <: AbstractMCMC.AbstractSampler\n\nA RepeatSampler is a container for a sampler and a number of times to repeat it.\n\nFields\n\nsampler: The sampler to repeat\nnum_repeat: The number of times to repeat the sampler\n\nExamples\n\nrepeated_sampler = RepeatSampler(sampler, 10)\nAbstractMCMC.step(rng, model, repeated_sampler) # take 10 steps of `sampler`\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC{AD,space}\n\nStochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.e\n\nFields\n\nlearning_rate::Real\nmomentum_decay::Real\nadtype::Any\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGHMC-Tuple{Vararg{Symbol}}","page":"Inference","title":"Turing.Inference.SGHMC","text":"SGHMC(\n    space::Symbol...;\n    learning_rate::Real,\n    momentum_decay::Real,\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nCreate a Stochastic Gradient Hamiltonian Monte Carlo (SGHMC) sampler.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nTianqi Chen, Emily Fox, & Carlos Guestrin (2014). Stochastic Gradient Hamiltonian Monte Carlo. In: Proceedings of the 31st International Conference on Machine Learning (pp. 1683–1691).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SGLD","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nFields\n\nstepsize::Any: Step size function.\nadtype::Any\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SGLD-Tuple{Vararg{Symbol}}","page":"Inference","title":"Turing.Inference.SGLD","text":"SGLD(\n    space::Symbol...;\n    stepsize = PolynomialStepsize(0.01),\n    adtype::ADTypes.AbstractADType = AutoForwardDiff(),\n)\n\nStochastic gradient Langevin dynamics (SGLD) sampler.\n\nBy default, a polynomially decaying stepsize is used.\n\nIf the automatic differentiation (AD) backend adtype is not provided, ForwardDiff with automatically determined chunksize is used.\n\nReference\n\nMax Welling & Yee Whye Teh (2011). Bayesian Learning via Stochastic Gradient Langevin Dynamics. In: Proceedings of the 28th International Conference on Machine Learning (pp. 681–688).\n\nSee also: PolynomialStepsize\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.SMC","page":"Inference","title":"Turing.Inference.SMC","text":"SMC(space...)\nSMC([resampler = AdvancedPS.ResampleWithESSThreshold(), space = ()])\nSMC([resampler = AdvancedPS.resample_systematic, ]threshold[, space = ()])\n\nCreate a sequential Monte Carlo sampler of type SMC for the variables in space.\n\nIf the algorithm for the resampling step is not specified explicitly, systematic resampling is performed if the estimated effective sample size per particle drops below 0.5.\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.SMC-2","page":"Inference","title":"Turing.Inference.SMC","text":"struct SMC{space, R} <: Turing.Inference.ParticleInference\n\nSequential Monte Carlo sampler.\n\nFields\n\nresampler::Any\n\n\n\n\n\n","category":"type"},{"location":"api/Inference/#Turing.Inference.dist_val_tuple-Tuple{DynamicPPL.Sampler{<:MH}, Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta}","page":"Inference","title":"Turing.Inference.dist_val_tuple","text":"dist_val_tuple(spl::Sampler{<:MH}, vi::VarInfo)\n\nReturn two NamedTuples.\n\nThe first NamedTuple has symbols as keys and distributions as values. The second NamedTuple has model symbols as keys and their stored values as values.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.drop_space","page":"Inference","title":"Turing.Inference.drop_space","text":"drop_space(alg::InferenceAlgorithm)\n\nReturn an InferenceAlgorithm like alg, but with all space information removed.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.externalsampler-Tuple{AbstractMCMC.AbstractSampler}","page":"Inference","title":"Turing.Inference.externalsampler","text":"externalsampler(sampler::AbstractSampler; adtype=AutoForwardDiff(), unconstrained=true)\n\nWrap a sampler so it can be used as an inference algorithm.\n\nArguments\n\nsampler::AbstractSampler: The sampler to wrap.\n\nKeyword Arguments\n\nadtype::ADTypes.AbstractADType=ADTypes.AutoForwardDiff(): The automatic differentiation (AD) backend to use.\nunconstrained::Bool=true: Whether the sampler requires unconstrained space.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.getparams-Tuple{Any, Any}","page":"Inference","title":"Turing.Inference.getparams","text":"getparams(model, t)\n\nReturn a named tuple of parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.gibbs_initialstep_recursive","page":"Inference","title":"Turing.Inference.gibbs_initialstep_recursive","text":"Take the first step of MCMC for the first component sampler, and call the same function recursively on the remaining samplers, until no samplers remain. Return the global VarInfo and a tuple of initial states for all component samplers.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.gibbs_step_recursive","page":"Inference","title":"Turing.Inference.gibbs_step_recursive","text":"Run a Gibbs step for the first varname/sampler/state tuple, and recursively call the same function on the tail, until there are no more samplers left.\n\n\n\n\n\n","category":"function"},{"location":"api/Inference/#Turing.Inference.group_varnames_by_symbol-Tuple{Any}","page":"Inference","title":"Turing.Inference.group_varnames_by_symbol","text":"group_varnames_by_symbol(vns)\n\nGroup the varnames by their symbol.\n\nArguments\n\nvns: Iterable of VarName.\n\nReturns\n\nOrderedDict{Symbol, Vector{VarName}}: A dictionary mapping symbol to a vector of varnames.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.isgibbscomponent-Tuple{Turing.Inference.InferenceAlgorithm}","page":"Inference","title":"Turing.Inference.isgibbscomponent","text":"isgibbscomponent(alg::Union{InferenceAlgorithm, AbstractMCMC.AbstractSampler})\n\nReturn a boolean indicating whether alg is a valid component for a Gibbs sampler.\n\nDefaults to false if no method has been defined for a particular algorithm type.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.make_conditional-Tuple{DynamicPPL.Model, AbstractVector{<:AbstractPPL.VarName}, Any}","page":"Inference","title":"Turing.Inference.make_conditional","text":"make_conditional(model, target_variables, varinfo)\n\nReturn a new, conditioned model for a component of a Gibbs sampler.\n\nArguments\n\nmodel::DynamicPPL.Model: The model to condition.\ntarget_variables::AbstractVector{<:VarName}: The target variables of the component\n\nsampler. These will not be conditioned.\n\nvarinfo::DynamicPPL.AbstractVarInfo: Values for all variables in the model. All the\n\nvalues in varinfo but not in target_variables will be conditioned to the values they have in varinfo.\n\nReturns\n\nA new model with the variables not in target_variables conditioned.\nThe GibbsContext object that will be used to condition the variables. This is necessary\n\nbecause evaluation can mutate its global_varinfo field, which we need to access later.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.match_linking!!-Tuple{Any, Any, Any}","page":"Inference","title":"Turing.Inference.match_linking!!","text":"match_linking!!(varinfo_local, prev_state_local, model)\n\nMake sure the linked/invlinked status of varinfo_local matches that of the previous state for this sampler. This is relevant when multilple samplers are sampling the same variables, and one might need it to be linked while the other doesn't.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.mh_accept-Tuple{Real, Real, Real}","page":"Inference","title":"Turing.Inference.mh_accept","text":"mh_accept(logp_current::Real, logp_proposal::Real, log_proposal_ratio::Real)\n\nDecide if a proposal x with log probability log p(x) = logp_proposal and log proposal ratio log k(x x) - log k(x x) = log_proposal_ratio in a Metropolis-Hastings algorithm with Markov kernel k(x_t x_t+1) and current state x with log probability log p(x) = logp_current is accepted by evaluating the Metropolis-Hastings acceptance criterion\n\nlog U leq log p(x) - log p(x) + log k(x x) - log k(x x)\n\nfor a uniform random number U in 0 1).\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.requires_unconstrained_space-Union{Tuple{Turing.Inference.ExternalSampler{<:Any, <:Any, Unconstrained}}, Tuple{Unconstrained}} where Unconstrained","page":"Inference","title":"Turing.Inference.requires_unconstrained_space","text":"requires_unconstrained_space(sampler::ExternalSampler)\n\nReturn true if the sampler requires unconstrained space, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.set_namedtuple!-Tuple{Union{DynamicPPL.ThreadSafeVarInfo{<:DynamicPPL.VarInfo{Tmeta}}, DynamicPPL.VarInfo{Tmeta}} where Tmeta, NamedTuple}","page":"Inference","title":"Turing.Inference.set_namedtuple!","text":"set_namedtuple!(vi::VarInfo, nt::NamedTuple)\n\nPlaces the values of a NamedTuple into the relevant places of a VarInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.setparams_varinfo!!-Tuple{Any, DynamicPPL.Sampler, Any, DynamicPPL.AbstractVarInfo}","page":"Inference","title":"Turing.Inference.setparams_varinfo!!","text":"setparams_varinfo!!(model, sampler::Sampler, state, params::AbstractVarInfo)\n\nA lot like AbstractMCMC.setparams!!, but instead of taking a vector of parameters, takes an AbstractVarInfo object. Also takes the sampler as an argument. By default, falls back to AbstractMCMC.setparams!!(model, state, params[:]).\n\nmodel is typically a DynamicPPL.Model, but can also be e.g. an AbstractMCMC.LogDensityModel.\n\n\n\n\n\n","category":"method"},{"location":"api/Inference/#Turing.Inference.transitions_from_chain-Tuple{DynamicPPL.Model, Chains}","page":"Inference","title":"Turing.Inference.transitions_from_chain","text":"transitions_from_chain(\n    [rng::AbstractRNG,]\n    model::Model,\n    chain::MCMCChains.Chains;\n    sampler = DynamicPPL.SampleFromPrior()\n)\n\nExecute model conditioned on each sample in chain, and return resulting transitions.\n\nThe returned transitions are represented in a Vector{<:Turing.Inference.Transition}.\n\nDetails\n\nIn a bit more detail, the process is as follows:\n\nFor every sample in chain\nFor every variable in sample\nSet variable in model to its value in sample\nExecute model with variables fixed as above, sampling variables NOT present in chain using SampleFromPrior\nReturn sampled variables and log-joint\n\nExample\n\njulia> using Turing\n\njulia> @model function demo()\n           m ~ Normal(0, 1)\n           x ~ Normal(m, 1)\n       end;\n\njulia> m = demo();\n\njulia> chain = Chains(randn(2, 1, 1), [\"m\"]); # 2 samples of `m`\n\njulia> transitions = Turing.Inference.transitions_from_chain(m, chain);\n\njulia> [Turing.Inference.getlogp(t) for t in transitions] # extract the logjoints\n2-element Array{Float64,1}:\n -3.6294991938628374\n -2.5697948166987845\n\njulia> [first(t.θ.x) for t in transitions] # extract samples for `x`\n2-element Array{Array{Float64,1},1}:\n [-2.0844148956440796]\n [-1.704630494695469]\n\n\n\n\n\n","category":"method"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Module-wide-re-exports","page":"API","title":"Module-wide re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Turing.jl directly re-exports the entire public API of the following packages:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Distributions.jl\nMCMCChains.jl\nAbstractMCMC.jl\nBijectors.jl\nLibtask.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Please see the individual packages for their documentation.","category":"page"},{"location":"api/#Individual-exports-and-re-exports","page":"API","title":"Individual exports and re-exports","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"All of the following symbols are exported unqualified by Turing, even though the documentation suggests that many of them are qualified. That means, for example, you can just write","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Turing\n\n@model function my_model() end\n\nsample(my_model(), Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"instead of","category":"page"},{"location":"api/","page":"API","title":"API","text":"DynamicPPL.@model function my_model() end\n\nsample(my_model(), Turing.Inference.Prior(), 100)","category":"page"},{"location":"api/","page":"API","title":"API","text":"even though Prior() is actually defined in the Turing.Inference module and @model in the DynamicPPL package.","category":"page"},{"location":"api/#Modelling","page":"API","title":"Modelling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\n@model DynamicPPL.@model Define a probabilistic model\n@varname AbstractPPL.@varname Generate a VarName from a Julia expression\nto_submodel DynamicPPL.to_submodel Define a submodel","category":"page"},{"location":"api/#Inference","page":"API","title":"Inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nsample StatsBase.sample Sample from a model","category":"page"},{"location":"api/#Samplers","page":"API","title":"Samplers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nPrior Turing.Inference.Prior Sample from the prior distribution\nMH Turing.Inference.MH Metropolis–Hastings\nEmcee Turing.Inference.Emcee Affine-invariant ensemble sampler\nESS Turing.Inference.ESS Elliptical slice sampling\nGibbs Turing.Inference.Gibbs Gibbs sampling\nHMC Turing.Inference.HMC Hamiltonian Monte Carlo\nSGLD Turing.Inference.SGLD Stochastic gradient Langevin dynamics\nSGHMC Turing.Inference.SGHMC Stochastic gradient Hamiltonian Monte Carlo\nPolynomialStepsize Turing.Inference.PolynomialStepsize Returns a function which generates polynomially decaying step sizes\nHMCDA Turing.Inference.HMCDA Hamiltonian Monte Carlo with dual averaging\nNUTS Turing.Inference.NUTS No-U-Turn Sampler\nIS Turing.Inference.IS Importance sampling\nSMC Turing.Inference.SMC Sequential Monte Carlo\nPG Turing.Inference.PG Particle Gibbs\nCSMC Turing.Inference.CSMC The same as PG\nexternalsampler Turing.Inference.externalsampler Wrap an external sampler for use in Turing","category":"page"},{"location":"api/#Variational-inference","page":"API","title":"Variational inference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See the variational inference tutorial for a walkthrough on how to use these.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nvi AdvancedVI.vi Perform variational inference\nADVI AdvancedVI.ADVI Construct an instance of a VI algorithm","category":"page"},{"location":"api/#Automatic-differentiation-types","page":"API","title":"Automatic differentiation types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These are used to specify the automatic differentiation backend to use. See the AD guide for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nAutoForwardDiff ADTypes.AutoForwardDiff ForwardDiff.jl backend\nAutoReverseDiff ADTypes.AutoReverseDiff ReverseDiff.jl backend\nAutoZygote ADTypes.AutoZygote Zygote.jl backend\nAutoMooncake ADTypes.AutoMooncake Mooncake.jl backend","category":"page"},{"location":"api/#Debugging","page":"API","title":"Debugging","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"setprogress!","category":"page"},{"location":"api/#Turing.setprogress!","page":"API","title":"Turing.setprogress!","text":"setprogress!(progress::Bool)\n\nEnable progress logging in Turing if progress is true, and disable it otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Distributions","page":"API","title":"Distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These distributions are defined in Turing.jl, but not in Distributions.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Flat\nFlatPos\nBinomialLogit\nOrderedLogistic\nLogPoisson","category":"page"},{"location":"api/#Turing.Flat","page":"API","title":"Turing.Flat","text":"Flat()\n\nThe flat distribution is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = 1\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.FlatPos","page":"API","title":"Turing.FlatPos","text":"FlatPos(l::Real)\n\nThe positive flat distribution with real-valued parameter l is the improper distribution of real numbers that has the improper probability density function\n\nf(x) = begincases\n0  textif  x leq l \n1  textotherwise\nendcases\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.BinomialLogit","page":"API","title":"Turing.BinomialLogit","text":"BinomialLogit(n, logitp)\n\nThe Binomial distribution with logit parameterization characterizes the number of successes in a sequence of independent trials.\n\nIt has two parameters: n, the number of trials, and logitp, the logit of the probability of success in an individual trial, with the distribution\n\nP(X = k) = n choose k(textlogistic(logitp))^k (1 - textlogistic(logitp))^n-k quad text for  k = 012 ldots n\n\nSee also: Binomial\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.OrderedLogistic","page":"API","title":"Turing.OrderedLogistic","text":"OrderedLogistic(η, c::AbstractVector)\n\nThe ordered logistic distribution with real-valued parameter η and cutpoints c has the probability mass function\n\nP(X = k) = begincases\n    1 - textlogistic(eta - c_1)  textif  k = 1 \n    textlogistic(eta - c_k-1) - textlogistic(eta - c_k)  textif  1  k  K \n    textlogistic(eta - c_K-1)  textif  k = K\nendcases\n\nwhere K = length(c) + 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Turing.LogPoisson","page":"API","title":"Turing.LogPoisson","text":"LogPoisson(logλ)\n\nThe Poisson distribution with logarithmic parameterization of the rate parameter describes the number of independent events occurring within a unit time interval, given the average rate of occurrence exp(loglambda).\n\nThe distribution has the probability mass function\n\nP(X = k) = frace^k cdot loglambdak e^-e^loglambda quad text for  k = 012ldots\n\nSee also: Poisson\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"BernoulliLogit is part of Distributions.jl since version 0.25.77. If you are using an older version of Distributions where this isn't defined, Turing will export the same distribution.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Distributions.BernoulliLogit","category":"page"},{"location":"api/#Distributions.BernoulliLogit","page":"API","title":"Distributions.BernoulliLogit","text":"BernoulliLogit(logitp=0.0)\n\nA Bernoulli distribution that is parameterized by the logit logitp = logit(p) = log(p/(1-p)) of its success rate p.\n\nP(X = k) = begincases\noperatornamelogistic(-logitp) = frac11 + exp(logitp)  quad textfor  k = 0 \noperatornamelogistic(logitp) = frac11 + exp(-logitp)  quad textfor  k = 1\nendcases\n\nExternal links:\n\nBernoulli distribution on Wikipedia\n\nSee also Bernoulli\n\n\n\n\n\n","category":"type"},{"location":"api/#Tools-to-work-with-distributions","page":"API","title":"Tools to work with distributions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nfilldist DistributionsAD.filldist Create a product distribution from a distribution and integers\narraydist DistributionsAD.arraydist Create a product distribution from an array of distributions\nNamedDist DynamicPPL.NamedDist A distribution that carries the name of the variable","category":"page"},{"location":"api/#Predictions","page":"API","title":"Predictions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"predict","category":"page"},{"location":"api/#Querying-model-probabilities-and-quantities","page":"API","title":"Querying model probabilities and quantities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Please see the generated quantities and probability interface guides for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\ngenerated_quantities DynamicPPL.generated_quantities Calculate additional quantities defined in a model\npointwise_loglikelihoods DynamicPPL.pointwise_loglikelihoods Compute log likelihoods for each sample in a chain\nlogprior DynamicPPL.logprior Compute log prior probability\nlogjoint DynamicPPL.logjoint Compute log joint probability\nLogDensityFunction DynamicPPL.LogDensityFunction Wrap a Turing model to satisfy LogDensityFunctions.jl interface\ncondition AbstractPPL.condition Condition a model on data\ndecondition AbstractPPL.decondition Remove conditioning on data\nconditioned DynamicPPL.conditioned Return the conditioned values of a model\nfix DynamicPPL.fix Fix the value of a variable\nunfix DynamicPPL.unfix Unfix the value of a variable\nOrderedDict OrderedCollections.OrderedDict An ordered dictionary","category":"page"},{"location":"api/#Extra-re-exports-from-Bijectors","page":"API","title":"Extra re-exports from Bijectors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Note that Bijectors itself does not export ordered.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Bijectors.ordered","category":"page"},{"location":"api/#Bijectors.ordered","page":"API","title":"Bijectors.ordered","text":"ordered(d::Distribution)\n\nReturn a Distribution whose support are ordered vectors, i.e., vectors with increasingly ordered elements.\n\nSpecifically, d is restricted to the subspace of its domain containing only ordered elements.\n\nwarning: Warning\nrand is implemented using rejection sampling, which can be slow for high-dimensional distributions. In such cases, consider using MCMC methods to sample from the distribution instead.\n\nwarning: Warning\nThe resulting ordered distribution is un-normalized, which can cause issues in some contexts, e.g. in hierarchical models where the parameters of the ordered distribution are themselves sampled. See the notes below for a more detailed discussion.\n\nNotes on ordered being un-normalized\n\nThe resulting ordered distribution is un-normalized. This is not a problem if used in a context where the normalizing factor is irrelevant, but if the value of the normalizing factor impacts the resulting computation, the results may be inaccurate.\n\nFor example, if the distribution is used in sampling a posterior distribution with MCMC and the parameters of the ordered distribution are themselves sampled, then the normalizing factor would in general be needed for accurate sampling, and ordered should not be used. However, if the parameters are fixed, then since MCMC does not require distributions be normalized, ordered may be used without problems.\n\nA common case is where the distribution being ordered is a joint distribution of n identical univariate distributions. In this case the normalization factor works out to be the constant n!, and ordered can again be used without problems even if the parameters of the univariate distribution are sampled.\n\n\n\n\n\n","category":"function"},{"location":"api/#Point-estimates","page":"API","title":"Point estimates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"See the mode estimation tutorial for more information.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Exported symbol Documentation Description\nmaximum_a_posteriori Turing.Optimisation.maximum_a_posteriori Find a MAP estimate for a model\nmaximum_likelihood Turing.Optimisation.maximum_likelihood Find a MLE estimate for a model\nMAP Turing.Optimisation.MAP Type to use with Optim.jl for MAP estimation\nMLE Turing.Optimisation.MLE Type to use with Optim.jl for MLE estimation","category":"page"},{"location":"#Turing.jl","page":"Home","title":"Turing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This site contains the API documentation for the identifiers exported by Turing.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are looking for usage examples and guides, please visit https://turinglang.org/docs.","category":"page"}]
}
